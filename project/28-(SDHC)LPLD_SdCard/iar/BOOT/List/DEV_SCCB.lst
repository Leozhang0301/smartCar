###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         23/Apr/2019  21:09:42
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  G:\AIcar\@@\k60_144\smartcar\lib\Jay\DEV_SCCB.c
#    Command line =  
#        -f C:\Users\admin\AppData\Local\Temp\EW275E.tmp
#        (G:\AIcar\@@\k60_144\smartcar\lib\Jay\DEV_SCCB.c -D LPLD_K60 -lCN
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\BOOT\List"
#        -lB
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\BOOT\List"
#        -o
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\BOOT\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        G:\AIcar\arm\inc\c\DLib_Config_Normal.h -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\app\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\HW\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\DEV\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Ports\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Source\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\option\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\common\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\driver\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\descriptor\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\class\"
#        -I
#        "G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Jay\"
#        -Ol -I G:\AIcar\arm\CMSIS\Core\Include\ -I
#        G:\AIcar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\BOOT\List\DEV_SCCB.lst
#    Object file  =  
#        G:\AIcar\@@\k60_144\smartcar\project\28-(SDHC)LPLD_SdCard\iar\BOOT\Obj\DEV_SCCB.o
#
###############################################################################

G:\AIcar\@@\k60_144\smartcar\lib\Jay\DEV_SCCB.c
      1          /*
      2           *  
      3           *  
      4           *  @JayLin林杰 @厦门大学嘉庚学院 @博学队
      5           */
      6          #include  "common.h"
      7          #include "include.h"
      8          
      9          static void SCCB_delay(uint16 i);
     10          
     11          /*!
     12           *  @brief      SCCB延迟函数
     13           *  @param      time    延时时间
     14           *  @since      v5.0
     15           */

   \                                 In section .text, align 2, keep-with-next
     16          static void SCCB_delay(vuint16 time)
     17          {
   \                     SCCB_delay: (+1)
   \        0x0   0xB401             PUSH     {R0}
   \        0x2   0xE004             B.N      ??SCCB_delay_0
     18              while(time)
     19              {
     20                  time--;
   \                     ??SCCB_delay_1: (+1)
   \        0x4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \        0x8   0x1E40             SUBS     R0,R0,#+1
   \        0xA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     21              }
   \                     ??SCCB_delay_0: (+1)
   \        0xE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD1F6             BNE.N    ??SCCB_delay_1
     22          }
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR               ;; return
     23          
     24          ///*!
     25          // *  @brief      SCCB管脚配置
     26          // *  @since      v5.0
     27          // */
     28          //void SCCB_GPIO_init(void)
     29          //{
     30          //  GPIO_InitTypeDef pta;
     31          //  /********用户可修改值 开始***********/
     32          //  pta.GPIO_PTx = PTA;
     33          //  pta.GPIO_Pins = GPIO_Pin12 | GPIO_Pin13;
     34          //  /********用户可修改值 结束***********/
     35          //  pta.GPIO_Dir = DIR_OUTPUT;
     36          //  pta.GPIO_Output = OUTPUT_H;
     37          //  pta.GPIO_PinControl = NULL;
     38          //  LPLD_GPIO_Init(pta);
     39          //}

   \                                 In section .text, align 2, keep-with-next
     40          void SCCB_GPIO_init(void)
     41          {
   \                     SCCB_GPIO_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
     42            GPIO_InitTypeDef pta;
     43            /********用户可修改值 开始***********/
     44            pta.GPIO_PTx = PTA;
   \        0x4   0x....             LDR.N    R0,??DataTable8  ;; 0x400ff000
   \        0x6   0x9001             STR      R0,[SP, #+4]
     45            pta.GPIO_Pins = GPIO_Pin12 | GPIO_Pin13;
   \        0x8   0xF44F 0x5040      MOV      R0,#+12288
   \        0xC   0x9002             STR      R0,[SP, #+8]
     46            /********用户可修改值 结束***********/
     47            pta.GPIO_Dir = DIR_OUTPUT;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF88D 0x0010      STRB     R0,[SP, #+16]
     48            pta.GPIO_Output = OUTPUT_H;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF88D 0x0011      STRB     R0,[SP, #+17]
     49            pta.GPIO_PinControl = NULL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9003             STR      R0,[SP, #+12]
     50            LPLD_GPIO_Init(pta);
   \       0x1E   0xA901             ADD      R1,SP,#+4
   \       0x20   0xB084             SUB      SP,SP,#+16
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x2214             MOVS     R2,#+20
   \       0x26   0x....'....        BL       __aeabi_memcpy4
   \       0x2A   0xBC0F             POP      {R0-R3}
   \       0x2C   0x....'....        BL       LPLD_GPIO_Init
     51          }
   \       0x30   0xB007             ADD      SP,SP,#+28
   \       0x32   0xBD00             POP      {PC}             ;; return
     52          /*!
     53           *  @brief      SCCB起始信号
     54           *  @since      v5.0
     55           */

   \                                 In section .text, align 2, keep-with-next
     56          static uint8 SCCB_Start(void)
     57          {
   \                     SCCB_Start: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
     58              SDA_H();
   \        0x2   0x....             LDR.N    R4,??DataTable8_1  ;; 0x43fe0034
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x6020             STR      R0,[R4, #+0]
     59              SCL_H();
   \        0x8   0x....             LDR.N    R6,??DataTable8_2  ;; 0x43fe0030
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x6030             STR      R0,[R6, #+0]
     60              SCCB_DELAY();
   \        0xE   0xF44F 0x70C8      MOV      R0,#+400
   \       0x12   0x....'....        BL       SCCB_delay
     61          
     62              SDA_DDR_IN();
   \       0x16   0x....             LDR.N    R5,??DataTable8_3  ;; 0x43fe02b4
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6028             STR      R0,[R5, #+0]
     63              if(!SDA_IN())
   \       0x1C   0x....             LDR.N    R7,??DataTable8_4  ;; 0x43fe0234
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD103             BNE.N    ??SCCB_Start_0
     64              {
     65                  SDA_DDR_OUT();
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x6028             STR      R0,[R5, #+0]
     66                  return 0;   /* SDA线为低电平则总线忙,退出 */
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE011             B.N      ??SCCB_Start_1
     67              }
     68              SDA_DDR_OUT();
   \                     ??SCCB_Start_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x6028             STR      R0,[R5, #+0]
     69              SDA_L();
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6020             STR      R0,[R4, #+0]
     70          
     71              SCCB_DELAY();
   \       0x34   0xF44F 0x70C8      MOV      R0,#+400
   \       0x38   0x....'....        BL       SCCB_delay
     72              SCL_L();
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x6030             STR      R0,[R6, #+0]
     73          
     74              if(SDA_IN())
   \       0x40   0x6838             LDR      R0,[R7, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD003             BEQ.N    ??SCCB_Start_2
     75              {
     76                  SDA_DDR_OUT();
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x6028             STR      R0,[R5, #+0]
     77                  return 0;   /* SDA线为高电平则总线出错,退出 */
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE000             B.N      ??SCCB_Start_1
     78              }
     79              //SDA_DDR_OUT();
     80              //SDA_L();
     81              //SCCB_delay();
     82              return 1;
   \                     ??SCCB_Start_2: (+1)
   \       0x4E   0x2001             MOVS     R0,#+1
   \                     ??SCCB_Start_1: (+1)
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     83          }
     84          
     85          /*!
     86           *  @brief      SCCB停止信号
     87           *  @since      v5.0
     88           */

   \                                 In section .text, align 2, keep-with-next
     89          static void SCCB_Stop(void)
     90          {
   \                     SCCB_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     91              SCL_L();
   \        0x2   0x....             LDR.N    R4,??DataTable8_2  ;; 0x43fe0030
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6020             STR      R0,[R4, #+0]
     92              //SCCB_DELAY();
     93              SDA_L();
   \        0x8   0x....             LDR.N    R5,??DataTable8_1  ;; 0x43fe0034
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6028             STR      R0,[R5, #+0]
     94              SCCB_DELAY();
   \        0xE   0xF44F 0x70C8      MOV      R0,#+400
   \       0x12   0x....'....        BL       SCCB_delay
     95              SCL_H();
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x6020             STR      R0,[R4, #+0]
     96              SCCB_DELAY();
   \       0x1A   0xF44F 0x70C8      MOV      R0,#+400
   \       0x1E   0x....'....        BL       SCCB_delay
     97              SDA_H();
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x6028             STR      R0,[R5, #+0]
     98              SCCB_DELAY();
   \       0x26   0xF44F 0x70C8      MOV      R0,#+400
   \       0x2A   0x....'....        BL       SCCB_delay
     99          }
   \       0x2E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    100          
    101          /*!
    102           *  @brief      SCCB应答信号
    103           *  @since      v5.0
    104           */

   \                                 In section .text, align 2, keep-with-next
    105          static void SCCB_Ack(void)
    106          {
   \                     SCCB_Ack: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    107              SCL_L();
   \        0x2   0x....             LDR.N    R4,??DataTable8_2  ;; 0x43fe0030
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6020             STR      R0,[R4, #+0]
    108              SCCB_DELAY();
   \        0x8   0xF44F 0x70C8      MOV      R0,#+400
   \        0xC   0x....'....        BL       SCCB_delay
    109              SDA_L();
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x....             LDR.N    R1,??DataTable8_1  ;; 0x43fe0034
   \       0x14   0x6008             STR      R0,[R1, #+0]
    110              SCCB_DELAY();
   \       0x16   0xF44F 0x70C8      MOV      R0,#+400
   \       0x1A   0x....'....        BL       SCCB_delay
    111              SCL_H();
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x6020             STR      R0,[R4, #+0]
    112              SCCB_DELAY();
   \       0x22   0xF44F 0x70C8      MOV      R0,#+400
   \       0x26   0x....'....        BL       SCCB_delay
    113              SCL_L();
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6020             STR      R0,[R4, #+0]
    114              SCCB_DELAY();
   \       0x2E   0xF44F 0x70C8      MOV      R0,#+400
   \       0x32   0x....'....        BL       SCCB_delay
    115          }
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    116          
    117          /*!
    118           *  @brief      SCCB无应答信号
    119           *  @since      v5.0
    120           */

   \                                 In section .text, align 2, keep-with-next
    121          static void SCCB_NoAck(void)
    122          {
   \                     SCCB_NoAck: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    123              SCL_L();
   \        0x2   0x....             LDR.N    R4,??DataTable8_2  ;; 0x43fe0030
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6020             STR      R0,[R4, #+0]
    124              SCCB_DELAY();
   \        0x8   0xF44F 0x70C8      MOV      R0,#+400
   \        0xC   0x....'....        BL       SCCB_delay
    125              SDA_H();
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x....             LDR.N    R1,??DataTable8_1  ;; 0x43fe0034
   \       0x14   0x6008             STR      R0,[R1, #+0]
    126              SCCB_DELAY();
   \       0x16   0xF44F 0x70C8      MOV      R0,#+400
   \       0x1A   0x....'....        BL       SCCB_delay
    127              SCL_H();
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x6020             STR      R0,[R4, #+0]
    128              SCCB_DELAY();
   \       0x22   0xF44F 0x70C8      MOV      R0,#+400
   \       0x26   0x....'....        BL       SCCB_delay
    129              SCL_L();
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6020             STR      R0,[R4, #+0]
    130              SCCB_DELAY();
   \       0x2E   0xF44F 0x70C8      MOV      R0,#+400
   \       0x32   0x....'....        BL       SCCB_delay
    131          }
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    132          
    133          /*!
    134           *  @brief      SCCB 等待应答
    135           *  @return     应答结果（0表示无应答，1表示有应答）
    136           *  @since      v5.0
    137           */

   \                                 In section .text, align 2, keep-with-next
    138          static int SCCB_WaitAck(void)
    139          {
   \                     SCCB_WaitAck: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    140              SCL_L();
   \        0x2   0x....             LDR.N    R4,??DataTable8_2  ;; 0x43fe0030
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6020             STR      R0,[R4, #+0]
    141              //SDA_H();
    142              SDA_DDR_IN();
   \        0x8   0x....             LDR.N    R5,??DataTable8_3  ;; 0x43fe02b4
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6028             STR      R0,[R5, #+0]
    143          
    144              SCCB_DELAY();
   \        0xE   0xF44F 0x70C8      MOV      R0,#+400
   \       0x12   0x....'....        BL       SCCB_delay
    145              SCL_H();
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x6020             STR      R0,[R4, #+0]
    146          
    147              SCCB_DELAY();
   \       0x1A   0xF44F 0x70C8      MOV      R0,#+400
   \       0x1E   0x....'....        BL       SCCB_delay
    148          
    149              if(SDA_IN())           //应答为高电平，异常，通信失败
   \       0x22   0x....             LDR.N    R0,??DataTable8_4  ;; 0x43fe0234
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD005             BEQ.N    ??SCCB_WaitAck_0
    150              {
    151                  SDA_DDR_OUT();
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x6028             STR      R0,[R5, #+0]
    152                  SCL_L();
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6020             STR      R0,[R4, #+0]
    153                  return 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE004             B.N      ??SCCB_WaitAck_1
    154              }
    155              SDA_DDR_OUT();
   \                     ??SCCB_WaitAck_0: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x6028             STR      R0,[R5, #+0]
    156              SCL_L();
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6020             STR      R0,[R4, #+0]
    157              return 1;
   \       0x3E   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WaitAck_1: (+1)
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    158          }
    159          
    160          /*!
    161           *  @brief      SCCB 发送的数据
    162           *  @param      SendByte    需要发送的数据
    163           *  @since      v5.0
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          static void SCCB_SendByte(uint8 SendByte)
    166          {
   \                     SCCB_SendByte: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    167              uint8 i = 8;
   \        0x4   0x2508             MOVS     R5,#+8
   \        0x6   0xE016             B.N      ??SCCB_SendByte_0
    168              while(i--)
    169              {
    170          
    171                  if(SendByte & 0x80)     //SDA 输出数据
    172                  {
    173                      SDA_H();
    174                  }
    175                  else
    176                  {
    177                      SDA_L();
   \                     ??SCCB_SendByte_1: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....             LDR.N    R1,??DataTable8_1  ;; 0x43fe0034
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE004             B.N      ??SCCB_SendByte_2
    178                  }
   \                     ??SCCB_SendByte_3: (+1)
   \       0x10   0x0620             LSLS     R0,R4,#+24
   \       0x12   0xD5F9             BPL.N    ??SCCB_SendByte_1
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x....             LDR.N    R1,??DataTable8_1  ;; 0x43fe0034
   \       0x18   0x6008             STR      R0,[R1, #+0]
    179                  SendByte <<= 1;
   \                     ??SCCB_SendByte_2: (+1)
   \       0x1A   0x0064             LSLS     R4,R4,#+1
    180                  SCCB_DELAY();
   \       0x1C   0xF44F 0x70C8      MOV      R0,#+400
   \       0x20   0x....'....        BL       SCCB_delay
    181                  SCL_H();                //SCL 拉高，采集信号
   \       0x24   0x....             LDR.N    R6,??DataTable8_2  ;; 0x43fe0030
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x6030             STR      R0,[R6, #+0]
    182                  SCCB_DELAY();
   \       0x2A   0xF44F 0x70C8      MOV      R0,#+400
   \       0x2E   0x....'....        BL       SCCB_delay
    183                  SCL_L();                //SCL 时钟线拉低
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6030             STR      R0,[R6, #+0]
    184                  //SCCB_DELAY();
    185              }
   \                     ??SCCB_SendByte_0: (+1)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0x1E45             SUBS     R5,R0,#+1
   \       0x3A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1E7             BNE.N    ??SCCB_SendByte_3
    186              //SCL_L();
    187          }
   \                     ??SCCB_SendByte_4: (+1)
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
    188          
    189          /*!
    190           *  @brief      接收SCCB总线的数据
    191           *  @return     接收到的数据
    192           *  @since      v5.0
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          static int SCCB_ReceiveByte(void)
    195          {
   \                     SCCB_ReceiveByte: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    196              uint8 i = 8;
   \        0x2   0x2408             MOVS     R4,#+8
    197              uint8 ReceiveByte = 0;
   \        0x4   0x2600             MOVS     R6,#+0
    198          
    199              //SDA_H();
    200              //SCCB_DELAY();
    201              SDA_DDR_IN();
   \        0x6   0x....             LDR.N    R5,??DataTable8_3  ;; 0x43fe02b4
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x6028             STR      R0,[R5, #+0]
   \        0xC   0xE013             B.N      ??SCCB_ReceiveByte_0
    202          
    203              while(i--)
    204              {
    205                  ReceiveByte <<= 1;
   \                     ??SCCB_ReceiveByte_1: (+1)
   \        0xE   0x0076             LSLS     R6,R6,#+1
    206                  SCL_L();
   \       0x10   0x....             LDR.N    R7,??DataTable8_2  ;; 0x43fe0030
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6038             STR      R0,[R7, #+0]
    207                  SCCB_DELAY();
   \       0x16   0xF44F 0x70C8      MOV      R0,#+400
   \       0x1A   0x....'....        BL       SCCB_delay
    208                  SCL_H();
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x6038             STR      R0,[R7, #+0]
    209                  SCCB_DELAY();
   \       0x22   0xF44F 0x70C8      MOV      R0,#+400
   \       0x26   0x....'....        BL       SCCB_delay
    210          
    211                  if(SDA_IN())
   \       0x2A   0x....             LDR.N    R0,??DataTable8_4  ;; 0x43fe0234
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??SCCB_ReceiveByte_0
    212                  {
    213                      ReceiveByte |= 0x01;
   \       0x32   0xF056 0x0601      ORRS     R6,R6,#0x1
    214                  }
    215          
    216          
    217              }
   \                     ??SCCB_ReceiveByte_0: (+1)
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x1E44             SUBS     R4,R0,#+1
   \       0x3A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1E6             BNE.N    ??SCCB_ReceiveByte_1
    218              SDA_DDR_OUT();
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x6028             STR      R0,[R5, #+0]
    219              SCL_L();
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x....             LDR.N    R1,??DataTable8_2  ;; 0x43fe0030
   \       0x48   0x6008             STR      R0,[R1, #+0]
    220              return ReceiveByte;
   \       0x4A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x4C   0x0030             MOVS     R0,R6
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    221          }
    222          
    223          /*****************************************************************************************
    224          * 函数名：SCCB_WriteByte
    225          * 描述  ：写一字节数据
    226          * 输入  ：- WriteAddress: 待写入地址    - SendByte: 待写入数据  - DeviceAddress: 器件类型
    227          * 输出  ：返回为:=1成功写入,=0失败
    228          * 注意  ：无
    229          *****************************************************************************************/
    230          static int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte );
    231          
    232          

   \                                 In section .text, align 2, keep-with-next
    233          int SCCB_WriteByte( uint16 WriteAddress , uint8 SendByte )            //考虑到用sccb的管脚模拟，比较容易失败，因此多试几次
    234          {
   \                     SCCB_WriteByte: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    235              uint8 i = 0;
   \        0x6   0x2600             MOVS     R6,#+0
    236              while( 0 == SCCB_WriteByte_one ( WriteAddress, SendByte ) )
   \                     ??SCCB_WriteByte_0: (+1)
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x10   0x....'....        BL       SCCB_WriteByte_one
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD106             BNE.N    ??SCCB_WriteByte_1
    237              {
    238                  i++;
   \       0x18   0x1C76             ADDS     R6,R6,#+1
    239                  if(i == 20)
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1E   0x2814             CMP      R0,#+20
   \       0x20   0xD1F2             BNE.N    ??SCCB_WriteByte_0
    240                  {
    241                      return 0 ;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE000             B.N      ??SCCB_WriteByte_2
    242                  }
    243              }
    244              return 1;
   \                     ??SCCB_WriteByte_1: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_2: (+1)
   \       0x28   0xBD70             POP      {R4-R6,PC}       ;; return
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte )
    248          {
   \                     SCCB_WriteByte_one: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    249              if(!SCCB_Start())
   \        0x6   0x....'....        BL       SCCB_Start
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??SCCB_WriteByte_one_0
    250              {
    251                  return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE019             B.N      ??SCCB_WriteByte_one_1
    252              }
    253              SCCB_SendByte( DEV_ADR );                    /* 器件地址 */
   \                     ??SCCB_WriteByte_one_0: (+1)
   \       0x12   0x2042             MOVS     R0,#+66
   \       0x14   0x....'....        BL       SCCB_SendByte
    254              if( !SCCB_WaitAck() )
   \       0x18   0x....'....        BL       SCCB_WaitAck
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD103             BNE.N    ??SCCB_WriteByte_one_2
    255              {
    256                  SCCB_Stop();
   \       0x20   0x....'....        BL       SCCB_Stop
    257                  return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE00E             B.N      ??SCCB_WriteByte_one_1
    258              }
    259              SCCB_SendByte((uint8)(WriteAddress & 0x00FF));   /* 设置低起始地址 */
   \                     ??SCCB_WriteByte_one_2: (+1)
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x....'....        BL       SCCB_SendByte
    260              SCCB_WaitAck();
   \       0x30   0x....'....        BL       SCCB_WaitAck
    261              SCCB_SendByte(SendByte);
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0x....'....        BL       SCCB_SendByte
    262              SCCB_WaitAck();
   \       0x3C   0x....'....        BL       SCCB_WaitAck
    263              SCCB_Stop();
   \       0x40   0x....'....        BL       SCCB_Stop
    264              return 1;
   \       0x44   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_one_1: (+1)
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    265          }
    266          
    267          
    268          
    269          
    270          /******************************************************************************************************************
    271           * 函数名：SCCB_ReadByte
    272           * 描述  ：读取一串数据
    273           * 输入  ：- pBuffer: 存放读出数据  - length: 待读出长度    - ReadAddress: 待读出地址        - DeviceAddress: 器件类型
    274           * 输出  ：返回为:=1成功读入,=0失败
    275           * 注意  ：无
    276           **********************************************************************************************************************/
    277          static int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress);
    278          

   \                                 In section .text, align 2, keep-with-next
    279          int SCCB_ReadByte(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    280          {
   \                     SCCB_ReadByte: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    281              uint8 i = 0;
   \        0x8   0x2700             MOVS     R7,#+0
    282              while( 0 == SCCB_ReadByte_one(pBuffer, length, ReadAddress) )
   \                     ??SCCB_ReadByte_0: (+1)
   \        0xA   0x0032             MOVS     R2,R6
   \        0xC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x....'....        BL       SCCB_ReadByte_one
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD106             BNE.N    ??SCCB_ReadByte_1
    283              {
    284                  i++;
   \       0x1C   0x1C7F             ADDS     R7,R7,#+1
    285                  if(i == 30)
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x22   0x281E             CMP      R0,#+30
   \       0x24   0xD1F1             BNE.N    ??SCCB_ReadByte_0
    286                  {
    287                      return 0 ;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE000             B.N      ??SCCB_ReadByte_2
    288                  }
    289              }
    290              return 1;
   \                     ??SCCB_ReadByte_1: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_2: (+1)
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    291          }
    292          

   \                                 In section .text, align 2, keep-with-next
    293          int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    294          {
   \                     SCCB_ReadByte_one: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    295              if(!SCCB_Start())
   \        0x8   0x....'....        BL       SCCB_Start
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??SCCB_ReadByte_one_0
    296              {
    297                  return 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE038             B.N      ??SCCB_ReadByte_one_1
    298              }
    299              SCCB_SendByte( DEV_ADR );         /* 器件地址 */
   \                     ??SCCB_ReadByte_one_0: (+1)
   \       0x14   0x2042             MOVS     R0,#+66
   \       0x16   0x....'....        BL       SCCB_SendByte
    300              if( !SCCB_WaitAck() )
   \       0x1A   0x....'....        BL       SCCB_WaitAck
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD103             BNE.N    ??SCCB_ReadByte_one_2
    301              {
    302                  SCCB_Stop();
   \       0x22   0x....'....        BL       SCCB_Stop
    303                  return 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE02D             B.N      ??SCCB_ReadByte_one_1
    304              }
    305              SCCB_SendByte( ReadAddress );           /* 设置低起始地址 */
   \                     ??SCCB_ReadByte_one_2: (+1)
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2E   0x....'....        BL       SCCB_SendByte
    306              SCCB_WaitAck();
   \       0x32   0x....'....        BL       SCCB_WaitAck
    307              SCCB_Stop();
   \       0x36   0x....'....        BL       SCCB_Stop
    308          
    309              if(!SCCB_Start())
   \       0x3A   0x....'....        BL       SCCB_Start
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD101             BNE.N    ??SCCB_ReadByte_one_3
    310              {
    311                  return 0;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE01F             B.N      ??SCCB_ReadByte_one_1
    312              }
    313              SCCB_SendByte( DEV_ADR + 1 );               /* 器件地址 */
   \                     ??SCCB_ReadByte_one_3: (+1)
   \       0x46   0x2043             MOVS     R0,#+67
   \       0x48   0x....'....        BL       SCCB_SendByte
    314          
    315              if(!SCCB_WaitAck())
   \       0x4C   0x....'....        BL       SCCB_WaitAck
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD111             BNE.N    ??SCCB_ReadByte_one_4
    316              {
    317                  SCCB_Stop();
   \       0x54   0x....'....        BL       SCCB_Stop
    318                  return 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE014             B.N      ??SCCB_ReadByte_one_1
    319              }
    320              while(length)
    321              {
    322                  *pBuffer = SCCB_ReceiveByte();
    323                  if(length == 1)
    324                  {
    325                      SCCB_NoAck();
    326                  }
    327                  else
    328                  {
    329                      SCCB_Ack();
   \                     ??SCCB_ReadByte_one_5: (+1)
   \       0x5C   0x....'....        BL       SCCB_Ack
   \       0x60   0xE008             B.N      ??SCCB_ReadByte_one_6
    330                  }
   \                     ??SCCB_ReadByte_one_7: (+1)
   \       0x62   0x....'....        BL       SCCB_ReceiveByte
   \       0x66   0x7020             STRB     R0,[R4, #+0]
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD1F5             BNE.N    ??SCCB_ReadByte_one_5
   \       0x70   0x....'....        BL       SCCB_NoAck
    331                  pBuffer++;
   \                     ??SCCB_ReadByte_one_6: (+1)
   \       0x74   0x1C64             ADDS     R4,R4,#+1
    332                  length--;
   \       0x76   0x1E6D             SUBS     R5,R5,#+1
    333              }
   \                     ??SCCB_ReadByte_one_4: (+1)
   \       0x78   0x0028             MOVS     R0,R5
   \       0x7A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD1F0             BNE.N    ??SCCB_ReadByte_one_7
    334              SCCB_Stop();
   \                     ??SCCB_ReadByte_one_8: (+1)
   \       0x80   0x....'....        BL       SCCB_Stop
    335              return 1;
   \       0x84   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_one_1: (+1)
   \       0x86   0xBD70             POP      {R4-R6,PC}       ;; return
    336          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x400F'F000        DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x43FE'0034        DC32     0x43fe0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x43FE'0030        DC32     0x43fe0030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x43FE'02B4        DC32     0x43fe02b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x43FE'0234        DC32     0x43fe0234
    337          
    338          
    339          
    340          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SCCB_Ack
         8   -> SCCB_delay
      48   SCCB_GPIO_init
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
       8   SCCB_NoAck
         8   -> SCCB_delay
      24   SCCB_ReadByte
        24   -> SCCB_ReadByte_one
      16   SCCB_ReadByte_one
        16   -> SCCB_Ack
        16   -> SCCB_NoAck
        16   -> SCCB_ReceiveByte
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
      24   SCCB_ReceiveByte
        24   -> SCCB_delay
      16   SCCB_SendByte
        16   -> SCCB_delay
      24   SCCB_Start
        24   -> SCCB_delay
      16   SCCB_Stop
        16   -> SCCB_delay
      16   SCCB_WaitAck
        16   -> SCCB_delay
      16   SCCB_WriteByte
        16   -> SCCB_WriteByte_one
      16   SCCB_WriteByte_one
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
       4   SCCB_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
      56  SCCB_Ack
      52  SCCB_GPIO_init
      56  SCCB_NoAck
      46  SCCB_ReadByte
     136  SCCB_ReadByte_one
      80  SCCB_ReceiveByte
      66  SCCB_SendByte
      82  SCCB_Start
      48  SCCB_Stop
      66  SCCB_WaitAck
      42  SCCB_WriteByte
      72  SCCB_WriteByte_one
      26  SCCB_delay

 
 848 bytes in section .text
 
 848 bytes of CODE memory

Errors: none
Warnings: 3
