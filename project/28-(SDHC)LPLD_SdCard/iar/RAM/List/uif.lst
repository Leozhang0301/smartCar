###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         18/May/2019  16:18:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  C:\Users\que\Desktop\AAA_xinbiao\smartcar\lib\common\uif.c
#    Command line =  
#        -f C:\Users\TEMPLA~1.000\AppData\Local\Temp\EWCFB2.tmp
#        (C:\Users\que\Desktop\AAA_xinbiao\smartcar\lib\common\uif.c -D
#        LPLD_K60 -lCN
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\RAM\List"
#        -lB
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\RAM\List"
#        -o
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\RAM\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\@@\605110 IAR for
#        ARM 8.30\arm\inc\c\DLib_Config_Normal.h" -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\app\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\HW\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\DEV\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Ports\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Source\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\option\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\common\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\driver\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\descriptor\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\class\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Me\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\app\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\app\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Jay\"
#        -Ol -I "D:\@@\605110 IAR for ARM 8.30\arm\CMSIS\Core\Include\" -I
#        "D:\@@\605110 IAR for ARM 8.30\arm\CMSIS\DSP\Include\" -D
#        ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\RAM\List\uif.lst
#    Object file  =  
#        C:\Users\que\Desktop\AAA_xinbiao\smartcar\project\28-(SDHC)LPLD_SdCard\iar\RAM\Obj\uif.o
#
###############################################################################

C:\Users\que\Desktop\AAA_xinbiao\smartcar\lib\common\uif.c
      1          /**
      2           * @file uif.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief 提供简单的交互接口
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * The commands, set/show parameters, and prompt are configured 
     10           * at the project level
     11           *
     12           * 版权所有:北京拉普兰德电子技术有限公司
     13           * http://www.lpld.cn
     14           * mail:support@lpld.cn
     15           *
     16           * @par
     17           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     18           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     19           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     20           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     21           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     22           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     23           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     24           */
     25          
     26          #include "common.h"
     27          #include "uif.h"
     28          
     29          /********************************************************************/
     30          /*
     31           * Global messages -- constant strings
     32           */

   \                                 In section .rodata, align 4
     33          const int8 HELPMSG[] =
   \                     HELPMSG:
   \        0x0   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     34              "Enter 'help' for help.\n";
     35          

   \                                 In section .rodata, align 4
     36          const int8 INVARG[] =
   \                     INVARG:
   \        0x0   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error: Invalid argument: %s\n";
     38          

   \                                 In section .rodata, align 4
     39          const int8 INVALUE[] = 
   \                     INVALUE:
   \        0x0   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \       0x1A   0x00 0x00          DC8 0, 0
     40              "Error: Invalid value: %s\n";
     41          
     42          /*
     43           * Strings used by this file only
     44           */

   \                                 In section .rodata, align 4
     45          static const int8 INVCMD[] =
   \                     INVCMD:
   \        0x0   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     46              "Error: No such command: %s\n";
     47          

   \                                 In section .rodata, align 4
     48          static const int8 HELPFORMAT[] = 
   \                     HELPFORMAT:
   \        0x0   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \       0x12   0x00 0x00          DC8 0, 0
     49              "%8s  %-25s %s %s\n";
     50          

   \                                 In section .rodata, align 4
     51          static const int8 SYNTAX[] = 
   \                     SYNTAX:
   \        0x0   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x1F   0x00               DC8 0
     52              "Error: Invalid syntax for: %s\n";
     53          

   \                                 In section .rodata, align 4
     54          static const int8 INVOPT[] = 
   \                     INVOPT:
   \        0x0   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \       0x25   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     55              "Error:  Invalid set/show option: %s\n";
     56          

   \                                 In section .rodata, align 4
     57          static const int8 OPTFMT[] = 
   \                     OPTFMT:
   \        0x0   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \        0x7   0x00               DC8 0
     58              "%12s: ";
     59          

   \                                 In section .bss, align 4
     60          static int8 cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \        0x0                      DS8 80

   \                                 In section .bss, align 4
     61          static int8 cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \        0x0                      DS8 80
     62          
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          int8 *get_line (int8 *line)
     65          {
   \                     get_line: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
     66              int32 pos;
     67              int32 ch;
     68          
     69              pos = 0;
   \        0x4   0x2500             MOVS     R5,#+0
     70              ch = (int32)in_char();
   \        0x6   0x....'....        BL       in_char
   \        0xA   0xE01F             B.N      ??get_line_0
     71              while ( (ch != 0x0D /* CR */) &&
     72                      (ch != 0x0A /* LF/NL */) &&
     73                      (pos < UIF_MAX_LINE))
     74              {
     75                  switch (ch)
     76                  {
     77                      case 0x08:      /* Backspace */
     78                      case 0x7F:      /* Delete */
     79                          if (pos > 0)
     80                          {
     81                              pos -= 1;
     82                              out_char(0x08);    /* backspace */
     83                              out_char(' ');
     84                              out_char(0x08);    /* backspace */
     85                          }
     86                          break;
     87                      default:
     88                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1: (+1)
   \        0xC   0x1C69             ADDS     R1,R5,#+1
   \        0xE   0x2950             CMP      R1,#+80
   \       0x10   0xDA08             BGE.N    ??get_line_2
     89                          {
     90                              if ((ch > 0x1f) && (ch < 0x80))
   \       0x12   0xF1B0 0x0120      SUBS     R1,R0,#+32
   \       0x16   0x2960             CMP      R1,#+96
   \       0x18   0xD204             BCS.N    ??get_line_2
     91                              {
     92                                  line[pos++] = (int8)ch;
   \       0x1A   0x5560             STRB     R0,[R4, R5]
   \       0x1C   0x1C6D             ADDS     R5,R5,#+1
     93                                  out_char((int8)ch);
   \       0x1E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x20   0x....'....        BL       out_char
     94                              }
     95                          }
     96                          break;
   \                     ??get_line_2: (+1)
   \       0x24   0xE010             B.N      ??get_line_3
   \                     ??get_line_4: (+1)
   \       0x26   0x0001             MOVS     R1,R0
   \       0x28   0x2908             CMP      R1,#+8
   \       0x2A   0xD001             BEQ.N    ??get_line_5
   \       0x2C   0x297F             CMP      R1,#+127
   \       0x2E   0xD1ED             BNE.N    ??get_line_1
   \                     ??get_line_5: (+1)
   \       0x30   0x2D01             CMP      R5,#+1
   \       0x32   0xDB09             BLT.N    ??get_line_6
   \       0x34   0x1E6D             SUBS     R5,R5,#+1
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x....'....        BL       out_char
   \       0x3C   0x2020             MOVS     R0,#+32
   \       0x3E   0x....'....        BL       out_char
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0x....'....        BL       out_char
     97                  }
     98                  ch = (int32)in_char();
   \                     ??get_line_6: (+1)
   \                     ??get_line_3: (+1)
   \       0x48   0x....'....        BL       in_char
     99              }
   \                     ??get_line_0: (+1)
   \       0x4C   0x280D             CMP      R0,#+13
   \       0x4E   0xD003             BEQ.N    ??get_line_7
   \       0x50   0x280A             CMP      R0,#+10
   \       0x52   0xD001             BEQ.N    ??get_line_7
   \       0x54   0x2D50             CMP      R5,#+80
   \       0x56   0xDBE6             BLT.N    ??get_line_4
    100              line[pos] = '\0';
   \                     ??get_line_7: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x5560             STRB     R0,[R4, R5]
    101              out_char(0x0D);    /* CR */
   \       0x5C   0x200D             MOVS     R0,#+13
   \       0x5E   0x....'....        BL       out_char
    102              out_char(0x0A);    /* LF */
   \       0x62   0x200A             MOVS     R0,#+10
   \       0x64   0x....'....        BL       out_char
    103          
    104              return line;
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          int32 make_argv (int8 *cmdline, int8 *argv[])
    109          {
   \                     make_argv: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0004             MOVS     R4,R0
    110              int32 argc, i, in_text;
    111          
    112              /* 
    113               * Break cmdline into strings and argv
    114               * It is permissible for argv to be NULL, in which case
    115               * the purpose of this routine becomes to count args
    116               */
    117              argc = 0;
   \        0x4   0x2000             MOVS     R0,#+0
    118              i = 0;
   \        0x6   0x2500             MOVS     R5,#+0
    119              in_text = FALSE;
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0xE00D             B.N      ??make_argv_0
    120              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    121              {
    122                  if (((cmdline[i] == ' ')   ||
    123                       (cmdline[i] == '\t')) )
    124                  {
    125                      if (in_text)
   \                     ??make_argv_1: (+1)
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD00A             BEQ.N    ??make_argv_2
    126                      {
    127                          /* end of command line argument */
    128                          cmdline[i] = '\0';
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x5562             STRB     R2,[R4, R5]
    129                          in_text = FALSE;
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0xE006             B.N      ??make_argv_2
    130                      }
    131                      else
    132                      {
    133                          /* still looking for next argument */
    134                          
    135                      }
    136                  }
    137                  else
    138                  {
    139                      /* got non-whitespace character */
    140                      if (in_text)
    141                      {
    142                      }
    143                      else
    144                      {
    145                          /* start of an argument */
    146                          in_text = TRUE;
    147                          if (argc < UIF_MAX_ARGS)
    148                          {
    149                              if (argv != NULL)
   \                     ??make_argv_3: (+1)
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD003             BEQ.N    ??make_argv_4
    150                                  argv[argc] = &cmdline[i];
   \       0x1C   0xEB04 0x0305      ADD      R3,R4,R5
   \       0x20   0xF841 0x3020      STR      R3,[R1, R0, LSL #+2]
    151                              argc++;
   \                     ??make_argv_4: (+1)
   \       0x24   0x1C40             ADDS     R0,R0,#+1
    152                          }
    153                          else
    154                              /*return argc;*/
    155                              break;
    156                      }
    157          
    158                  }
    159                  i++;    /* proceed to next character */
   \                     ??make_argv_2: (+1)
   \       0x26   0x1C6D             ADDS     R5,R5,#+1
   \                     ??make_argv_0: (+1)
   \       0x28   0x5763             LDRSB    R3,[R4, R5]
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xD00A             BEQ.N    ??make_argv_5
   \       0x2E   0x5763             LDRSB    R3,[R4, R5]
   \       0x30   0x2B20             CMP      R3,#+32
   \       0x32   0xD0EB             BEQ.N    ??make_argv_1
   \       0x34   0x5763             LDRSB    R3,[R4, R5]
   \       0x36   0x2B09             CMP      R3,#+9
   \       0x38   0xD0E8             BEQ.N    ??make_argv_1
   \       0x3A   0x2A00             CMP      R2,#+0
   \       0x3C   0xD1F3             BNE.N    ??make_argv_2
   \       0x3E   0x2201             MOVS     R2,#+1
   \       0x40   0x280A             CMP      R0,#+10
   \       0x42   0xDBE9             BLT.N    ??make_argv_3
    160              }
    161              if (argv != NULL)
   \                     ??make_argv_6: (+1)
   \                     ??make_argv_5: (+1)
   \       0x44   0x2900             CMP      R1,#+0
   \       0x46   0xD002             BEQ.N    ??make_argv_7
    162                  argv[argc] = NULL;
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    163              return argc;
   \                     ??make_argv_7: (+1)
   \       0x4E   0xBC30             POP      {R4,R5}
   \       0x50   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void run_cmd (void)
    168          {
   \                     run_cmd: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
    169              /*
    170               * Global array of pointers to emulate C argc,argv interface
    171               */
    172              int32 argc;
    173              int8 *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    174          
    175              get_line(cmdline1);
   \        0x6   0x....             LDR.N    R5,??DataTable4_3
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x....'....        BL       get_line
    176          
    177              if (!(argc = make_argv(cmdline1,argv)))
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x....'....        BL       make_argv
   \       0x16   0x0004             MOVS     R4,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD108             BNE.N    ??run_cmd_0
    178              {
    179                  /* no command entered, just a blank line */
    180                  strcpy(cmdline1,cmdline2);
   \       0x1C   0x....             LDR.N    R1,??DataTable4_4
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x....'....        BL       strcpy
    181                  argc = make_argv(cmdline1,argv);
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x....'....        BL       make_argv
   \       0x2C   0x0004             MOVS     R4,R0
    182              }
    183              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \       0x2E   0x....             LDR.N    R5,??DataTable4_4
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x7028             STRB     R0,[R5, #+0]
    184          
    185              if (argc)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD03E             BEQ.N    ??run_cmd_1
    186              {
    187                  int32 i;
    188                  for (i = 0; i < UIF_NUM_CMD; i++)
   \       0x38   0x2600             MOVS     R6,#+0
   \       0x3A   0xE000             B.N      ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \       0x3C   0x1C76             ADDS     R6,R6,#+1
   \                     ??run_cmd_2: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable4_5
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x4286             CMP      R6,R0
   \       0x44   0xDA30             BGE.N    ??run_cmd_4
    189                  {
    190                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \       0x46   0x271C             MOVS     R7,#+28
   \       0x48   0x....'....        LDR.W    R8,??DataTable4_6
   \       0x4C   0x9900             LDR      R1,[SP, #+0]
   \       0x4E   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x52   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x56   0x....'....        BL       strcasecmp
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD1EE             BNE.N    ??run_cmd_3
    191                      {
    192                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    193                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \       0x5E   0x1E60             SUBS     R0,R4,#+1
   \       0x60   0xFB07 0xF106      MUL      R1,R7,R6
   \       0x64   0x4441             ADD      R1,R8,R1
   \       0x66   0x6849             LDR      R1,[R1, #+4]
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xDB18             BLT.N    ??run_cmd_5
   \       0x6C   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x70   0x4440             ADD      R0,R8,R0
   \       0x72   0x6880             LDR      R0,[R0, #+8]
   \       0x74   0x1E61             SUBS     R1,R4,#+1
   \       0x76   0x4288             CMP      R0,R1
   \       0x78   0xDB11             BLT.N    ??run_cmd_5
    194                          {
    195                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \       0x7A   0xFB07 0xF006      MUL      R0,R7,R6
   \       0x7E   0x4440             ADD      R0,R8,R0
   \       0x80   0x7B00             LDRB     R0,[R0, #+12]
   \       0x82   0x07C0             LSLS     R0,R0,#+31
   \       0x84   0xD503             BPL.N    ??run_cmd_6
    196                              {
    197                                  strcpy(cmdline2,argv[0]);
   \       0x86   0x9900             LDR      R1,[SP, #+0]
   \       0x88   0x0028             MOVS     R0,R5
   \       0x8A   0x....'....        BL       strcpy
    198                              }
    199                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \       0x8E   0x4669             MOV      R1,SP
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0x437E             MULS     R6,R7,R6
   \       0x94   0xEB08 0x0206      ADD      R2,R8,R6
   \       0x98   0x6912             LDR      R2,[R2, #+16]
   \       0x9A   0x4790             BLX      R2
    200                              return;
   \       0x9C   0xE00B             B.N      ??run_cmd_7
    201                          }
    202                          else
    203                          {
    204                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \       0x9E   0x9900             LDR      R1,[SP, #+0]
   \       0xA0   0x....             LDR.N    R0,??DataTable4_7
   \       0xA2   0x....'....        BL       printf
    205                              return;
   \       0xA6   0xE006             B.N      ??run_cmd_7
    206                          }
    207                      }
    208                  }
    209                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \       0xA8   0x9900             LDR      R1,[SP, #+0]
   \       0xAA   0x....             LDR.N    R0,??DataTable4_8
   \       0xAC   0x....'....        BL       printf
    210                  printf(HELPMSG);
   \       0xB0   0x....             LDR.N    R0,??DataTable4_9
   \       0xB2   0x....'....        BL       printf
    211              }
    212          }
   \                     ??run_cmd_1: (+1)
   \                     ??run_cmd_7: (+1)
   \       0xB6   0xB00C             ADD      SP,SP,#+48
   \       0xB8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    213          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          uint32 get_value (int8 *s, int32 *success, int32 base)
    215          {
   \                     get_value: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    216              uint32 value;
    217              int8 *p;
    218          
    219              value = strtoul(s,&p,base);
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       strtoul
    220              if ((value == 0) && (p == s))
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD106             BNE.N    ??get_value_0
   \       0x12   0x9900             LDR      R1,[SP, #+0]
   \       0x14   0x42A1             CMP      R1,R4
   \       0x16   0xD103             BNE.N    ??get_value_0
    221              {
    222                  *success = FALSE;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6028             STR      R0,[R5, #+0]
    223                  return 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE001             B.N      ??get_value_1
    224              }
    225              else
    226              {
    227                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x6029             STR      R1,[R5, #+0]
    228                  return value;
   \                     ??get_value_1: (+1)
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229              }
    230          }
    231          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void uif_cmd_help (int32 argc, int8 **argv)
    233          {
   \                     uif_cmd_help: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    234              int32 index;
    235              
    236              (void)argc;
    237              (void)argv;
    238              
    239              printf("\n");
   \        0x2   0x....             ADR.N    R4,??DataTable4  ;; "\n"
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x....'....        BL       printf
    240              for (index = 0; index < UIF_NUM_CMD; index++)
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0xE014             B.N      ??uif_cmd_help_0
    241              {
    242                  printf(HELPFORMAT,
    243                      UIF_CMDTAB[index].cmd,
    244                      UIF_CMDTAB[index].description,
    245                      UIF_CMDTAB[index].cmd,
    246                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \        0xE   0x201C             MOVS     R0,#+28
   \       0x10   0x....             LDR.N    R1,??DataTable4_6
   \       0x12   0xFB00 0xF205      MUL      R2,R0,R5
   \       0x16   0x440A             ADD      R2,R1,R2
   \       0x18   0x6992             LDR      R2,[R2, #+24]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
   \       0x1C   0xFB00 0xF205      MUL      R2,R0,R5
   \       0x20   0x588B             LDR      R3,[R1, R2]
   \       0x22   0xFB00 0xF205      MUL      R2,R0,R5
   \       0x26   0x440A             ADD      R2,R1,R2
   \       0x28   0x6952             LDR      R2,[R2, #+20]
   \       0x2A   0xFB00 0xF005      MUL      R0,R0,R5
   \       0x2E   0x5809             LDR      R1,[R1, R0]
   \       0x30   0x....             LDR.N    R0,??DataTable4_10
   \       0x32   0x....'....        BL       printf
    247              }
   \       0x36   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_help_0: (+1)
   \       0x38   0x....             LDR.N    R0,??DataTable4_5
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x4285             CMP      R5,R0
   \       0x3E   0xDBE6             BLT.N    ??uif_cmd_help_1
    248              printf("\n");
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       printf
    249          }
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    250          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void uif_cmd_set (int32 argc, int8 **argv)
    252          {
   \                     uif_cmd_set: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    253              int32 index;
    254          
    255              printf("\n");
   \        0x8   0x....             ADR.N    R4,??DataTable4  ;; "\n"
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x....'....        BL       printf
    256              if (argc == 1)
   \       0x10   0x2D01             CMP      R5,#+1
   \       0x12   0xD11D             BNE.N    ??uif_cmd_set_0
    257              {
    258                  printf("Valid 'set' options:\n");
   \       0x14   0x....             LDR.N    R0,??DataTable4_11
   \       0x16   0x....'....        BL       printf
    259                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \       0x1A   0x2500             MOVS     R5,#+0
   \       0x1C   0xE010             B.N      ??uif_cmd_set_1
    260                  {
    261                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \       0x1E   0x2614             MOVS     R6,#+20
   \       0x20   0x....             LDR.N    R7,??DataTable4_12
   \       0x22   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x26   0x5839             LDR      R1,[R7, R0]
   \       0x28   0x....             LDR.N    R0,??DataTable4_13
   \       0x2A   0x....'....        BL       printf
    262                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \       0x2E   0xFB06 0xF605      MUL      R6,R6,R5
   \       0x32   0xEB07 0x0006      ADD      R0,R7,R6
   \       0x36   0x6901             LDR      R1,[R0, #+16]
   \       0x38   0x....             ADR.N    R0,??DataTable4_1  ;; "%s\n"
   \       0x3A   0x....'....        BL       printf
    263                  }
   \       0x3E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_set_1: (+1)
   \       0x40   0x....             LDR.N    R0,??DataTable4_14
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0x4285             CMP      R5,R0
   \       0x46   0xDBEA             BLT.N    ??uif_cmd_set_2
    264                  printf("\n");
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x....'....        BL       printf
    265                  return;
   \       0x4E   0xE037             B.N      ??uif_cmd_set_3
    266              }
    267          
    268              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \       0x50   0x2D03             CMP      R5,#+3
   \       0x52   0xD003             BEQ.N    ??uif_cmd_set_4
    269              {
    270                  printf("Error: Invalid argument list\n");
   \       0x54   0x....             LDR.N    R0,??DataTable4_15
   \       0x56   0x....'....        BL       printf
    271                  return;
   \       0x5A   0xE031             B.N      ??uif_cmd_set_3
    272              }
    273          
    274              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \       0x5C   0x2400             MOVS     R4,#+0
   \       0x5E   0xE000             B.N      ??uif_cmd_set_5
   \                     ??uif_cmd_set_6: (+1)
   \       0x60   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_5: (+1)
   \       0x62   0x....             LDR.N    R0,??DataTable4_14
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x4284             CMP      R4,R0
   \       0x68   0xDA26             BGE.N    ??uif_cmd_set_7
    275              {
    276                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \       0x6A   0x2714             MOVS     R7,#+20
   \       0x6C   0x....'....        LDR.W    R8,??DataTable4_12
   \       0x70   0x6871             LDR      R1,[R6, #+4]
   \       0x72   0xFB07 0xF004      MUL      R0,R7,R4
   \       0x76   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x7A   0x....'....        BL       strcasecmp
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD1EE             BNE.N    ??uif_cmd_set_6
    277                  {
    278                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    279                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \       0x82   0x1EA8             SUBS     R0,R5,#+2
   \       0x84   0xFB07 0xF104      MUL      R1,R7,R4
   \       0x88   0x4441             ADD      R1,R8,R1
   \       0x8A   0x6849             LDR      R1,[R1, #+4]
   \       0x8C   0x4288             CMP      R0,R1
   \       0x8E   0xDB0E             BLT.N    ??uif_cmd_set_8
   \       0x90   0xFB07 0xF004      MUL      R0,R7,R4
   \       0x94   0x4440             ADD      R0,R8,R0
   \       0x96   0x6880             LDR      R0,[R0, #+8]
   \       0x98   0x1EA9             SUBS     R1,R5,#+2
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xDB07             BLT.N    ??uif_cmd_set_8
    280                      {
    281                          UIF_SETCMDTAB[index].func(argc,argv);
   \       0x9E   0x0031             MOVS     R1,R6
   \       0xA0   0x0028             MOVS     R0,R5
   \       0xA2   0x437C             MULS     R4,R7,R4
   \       0xA4   0xEB08 0x0204      ADD      R2,R8,R4
   \       0xA8   0x68D2             LDR      R2,[R2, #+12]
   \       0xAA   0x4790             BLX      R2
    282                          return;
   \       0xAC   0xE008             B.N      ??uif_cmd_set_3
    283                      }
    284                      else
    285                      {
    286                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \       0xAE   0x6871             LDR      R1,[R6, #+4]
   \       0xB0   0x....             LDR.N    R0,??DataTable4_16
   \       0xB2   0x....'....        BL       printf
    287                          return;
   \       0xB6   0xE003             B.N      ??uif_cmd_set_3
    288                      }
    289                  }
    290              }
    291              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \       0xB8   0x6871             LDR      R1,[R6, #+4]
   \       0xBA   0x....             LDR.N    R0,??DataTable4_17
   \       0xBC   0x....'....        BL       printf
    292          }
   \                     ??uif_cmd_set_3: (+1)
   \       0xC0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    293          
    294          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void uif_cmd_show (int32 argc, int8 **argv)
    296          {
   \                     uif_cmd_show: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
    297              int32 index;
    298          
    299              printf("\n");
   \        0x8   0x....             ADR.N    R5,??DataTable4  ;; "\n"
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x....'....        BL       printf
    300              if (argc == 1)
   \       0x10   0x2E01             CMP      R6,#+1
   \       0x12   0xD123             BNE.N    ??uif_cmd_show_0
    301              {
    302                  /*
    303                   * Show all Option settings
    304                   */
    305                  argc = 2;
   \       0x14   0x2602             MOVS     R6,#+2
    306                  argv[2] = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
    307                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \       0x1A   0x2700             MOVS     R7,#+0
   \       0x1C   0xE016             B.N      ??uif_cmd_show_1
    308                  {
    309                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \       0x1E   0xF05F 0x0814      MOVS     R8,#+20
   \       0x22   0x....'....        LDR.W    R9,??DataTable4_12
   \       0x26   0xFB08 0xF007      MUL      R0,R8,R7
   \       0x2A   0xF859 0x1000      LDR      R1,[R9, R0]
   \       0x2E   0x....             LDR.N    R0,??DataTable4_13
   \       0x30   0x....'....        BL       printf
    310                      UIF_SETCMDTAB[index].func(argc,argv);
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0x0030             MOVS     R0,R6
   \       0x38   0xFB08 0xF807      MUL      R8,R8,R7
   \       0x3C   0xEB09 0x0208      ADD      R2,R9,R8
   \       0x40   0x68D2             LDR      R2,[R2, #+12]
   \       0x42   0x4790             BLX      R2
    311                      printf("\n");
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x....'....        BL       printf
    312                  }
   \       0x4A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??uif_cmd_show_1: (+1)
   \       0x4C   0x....             LDR.N    R0,??DataTable4_14
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0x4287             CMP      R7,R0
   \       0x52   0xDBE4             BLT.N    ??uif_cmd_show_2
    313                  printf("\n");
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x....'....        BL       printf
    314                  return;
   \       0x5A   0xE03B             B.N      ??uif_cmd_show_3
    315              }
    316          
    317              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \       0x5C   0x2500             MOVS     R5,#+0
   \       0x5E   0xE000             B.N      ??uif_cmd_show_4
   \                     ??uif_cmd_show_5: (+1)
   \       0x60   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_show_4: (+1)
   \       0x62   0x....             LDR.N    R0,??DataTable4_14
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x4285             CMP      R5,R0
   \       0x68   0xDA30             BGE.N    ??uif_cmd_show_6
    318              {
    319                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \       0x6A   0x2714             MOVS     R7,#+20
   \       0x6C   0x....'....        LDR.W    R8,??DataTable4_12
   \       0x70   0x6861             LDR      R1,[R4, #+4]
   \       0x72   0xFB07 0xF005      MUL      R0,R7,R5
   \       0x76   0xF858 0x0000      LDR      R0,[R8, R0]
   \       0x7A   0x....'....        BL       strcasecmp
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD1EE             BNE.N    ??uif_cmd_show_5
    320                  {
    321                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    322                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \       0x82   0x1EB0             SUBS     R0,R6,#+2
   \       0x84   0xFB07 0xF105      MUL      R1,R7,R5
   \       0x88   0x4441             ADD      R1,R8,R1
   \       0x8A   0x6849             LDR      R1,[R1, #+4]
   \       0x8C   0x4288             CMP      R0,R1
   \       0x8E   0xDB18             BLT.N    ??uif_cmd_show_7
   \       0x90   0xFB07 0xF005      MUL      R0,R7,R5
   \       0x94   0x4440             ADD      R0,R8,R0
   \       0x96   0x6880             LDR      R0,[R0, #+8]
   \       0x98   0x1EB1             SUBS     R1,R6,#+2
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xDB11             BLT.N    ??uif_cmd_show_7
    323                      {
    324                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \       0x9E   0xFB07 0xF005      MUL      R0,R7,R5
   \       0xA2   0xF858 0x1000      LDR      R1,[R8, R0]
   \       0xA6   0x....             LDR.N    R0,??DataTable4_13
   \       0xA8   0x....'....        BL       printf
    325                          UIF_SETCMDTAB[index].func(argc,argv);
   \       0xAC   0x0021             MOVS     R1,R4
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0x437D             MULS     R5,R7,R5
   \       0xB2   0xEB08 0x0205      ADD      R2,R8,R5
   \       0xB6   0x68D2             LDR      R2,[R2, #+12]
   \       0xB8   0x4790             BLX      R2
    326                          printf("\n\n");
   \       0xBA   0x....             ADR.N    R0,??DataTable4_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \       0xBC   0x....'....        BL       printf
    327                          return;
   \       0xC0   0xE008             B.N      ??uif_cmd_show_3
    328                      }
    329                      else
    330                      {
    331                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \       0xC2   0x6861             LDR      R1,[R4, #+4]
   \       0xC4   0x....             LDR.N    R0,??DataTable4_16
   \       0xC6   0x....'....        BL       printf
    332                          return;
   \       0xCA   0xE003             B.N      ??uif_cmd_show_3
    333                      }
    334                  }
    335              }
    336              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \       0xCC   0x6861             LDR      R1,[R4, #+4]
   \       0xCE   0x....             LDR.N    R0,??DataTable4_17
   \       0xD0   0x....'....        BL       printf
    337          }
   \                     ??uif_cmd_show_3: (+1)
   \       0xD4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x....'....        DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x....'....        DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x....'....        DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x....'....        DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x....'....        DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x....'....        DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \        0x0   0x....'....        DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \        0x0   0x....'....        DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \        0x0   0x....'....        DC32     INVOPT

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \        0x3   0x00               DC8 0
    338          
    339          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
       8   make_argv
      72   run_cmd
        72   -- Indirect call
        72   -> get_line
        72   -> make_argv
        72   -> printf
        72   -> strcasecmp
        72   -> strcpy
      16   uif_cmd_help
        16   -> printf
      24   uif_cmd_set
        24   -- Indirect call
        24   -> printf
        24   -> strcasecmp
      32   uif_cmd_show
        32   -- Indirect call
        32   -> printf
        32   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     108  get_line
      38  get_value
      82  make_argv
     188  run_cmd
      72  uif_cmd_help
     196  uif_cmd_set
     216  uif_cmd_show

 
 160 bytes in section .bss
 278 bytes in section .rodata
 972 bytes in section .text
 
 972 bytes of CODE  memory
 278 bytes of CONST memory
 160 bytes of DATA  memory

Errors: none
Warnings: 1
