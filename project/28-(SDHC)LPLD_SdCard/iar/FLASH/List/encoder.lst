###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         08/Jul/2019  00:40:54
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  G:\AIcar\@@\xiugai\lib\common\encoder.c
#    Command line =  
#        -f C:\Users\admin\AppData\Local\Temp\EW5CF4.tmp
#        (G:\AIcar\@@\xiugai\lib\common\encoder.c -D LPLD_K60 -lCN
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -lB
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -o "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        G:\AIcar\arm\inc\c\DLib_Config_Normal.h -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\app\" -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\HW\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\DEV\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Ports\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Source\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\option\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\driver\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\descriptor\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\class\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Jay\"
#        -On -I G:\AIcar\arm\CMSIS\Core\Include\ -I
#        G:\AIcar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List\encoder.lst
#    Object file  =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj\encoder.o
#
###############################################################################

G:\AIcar\@@\xiugai\lib\common\encoder.c
      1          /**
      2          * --------------基于"拉普兰德K60底层库V3"的工程（LPLD_QuadratureDecoder）-----------------
      3          * @file LPLD_QuadratureDecoder.c
      4          * @version 0.1
      5          * @date 2013-9-29
      6          * @BRIEF 利用FTM模块的正交解码功能，实现编码器的正反转测速。
      7          *
      8          * 版权所有:北京拉普兰德电子技术有限公司
      9          * http://www.lpld.cn
     10          * mail:support@lpld.cn
     11          * 硬件平台:  LPLD K60 Card / LPLD K60 Nano
     12          *
     13          * 本工程基于"拉普兰德K60底层库V3"开发，
     14          * 所有开源代码均在"lib"文件夹下，用户不必更改该目录下代码，
     15          * 所有用户工程需保存在"project"文件夹下，以工程名定义文件夹名，
     16          * 底层库使用方法见相关文档。
     17          *
     18          */
     19          #include "include.h"
     20          
     21          
     22          
     23          /****************************************
     24          说明：
     25          *分别将编码器的AB相信号接入PTB0、PTB1引脚
     26          *将MiniUSB线插入RUSH Kinetis开发板的USB
     27          插座，并连接至电脑USB接口。
     28          *使用串口调试助手波特率设置为115200
     29          *使用串口调试助手查看运行结果。
     30          *使编码器产生正反转，查看运行结果。
     31          ****************************************/
     32          
     33          //函数声明
     34          void L1_init();
     35          void L2_init();
     36          void R1_init();
     37          void R2_init();
     38          void porta_isr(void);
     39          
     40          
     41          
     42          //变量定义
     43          int left_getSpeed();
     44          int right_getSpeed();

   \                                 In section .bss, align 4
     45          int left_reSpeed;
   \                     left_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     46          int right_reSpeed;
   \                     right_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     47          int r1_reSpeed=0;
   \                     r1_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     48          int r2_reSpeed=0;
   \                     r2_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     49          int l1_reSpeed=0;
   \                     l1_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     50          int l2_reSpeed=0;
   \                     l2_reSpeed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     51          int speed=0;
   \                     speed:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     52          int gpioSpeed;
   \                     gpioSpeed:
   \        0x0                      DS8 4
     53          

   \                                 In section .bss, align 4
     54          int flag1;
   \                     flag1:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     55          int flag;
   \                     flag:
   \        0x0                      DS8 4
     56          

   \                                 In section .bss, align 4
     57          FTM_InitTypeDef ftm1_init_struct; 
   \                     ftm1_init_struct:
   \        0x0                      DS8 28

   \                                 In section .bss, align 4
     58          LPTMR_InitTypeDef lptmr_init_structure;
   \                     lptmr_init_structure:
   \        0x0                      DS8 12

   \                                 In section .bss, align 4
     59          GPIO_InitTypeDef gpio_init_struct;
   \                     gpio_init_struct:
   \        0x0                      DS8 20
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void encorder_init()
     62          {
   \                     encorder_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     63            L1_init();
   \        0x2   0x....'....        BL       L1_init
     64            L2_init();
   \        0x6   0x....'....        BL       L2_init
     65            R1_init();
   \        0xA   0x....'....        BL       R1_init
     66            R2_init();
   \        0xE   0x....'....        BL       R2_init
     67          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
     68          
     69          /*********************************
     70          编码器R1
     71          **********************************/ 

   \                                 In section .text, align 2, keep-with-next
     72          void R1_init(void)
     73          {
   \                     R1_init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
     74            
     75            //配置正交解码功能参数
     76            ftm1_init_struct.FTM_Ftmx = FTM2;              //只有FTM1和FTM2有正交解码功能
   \        0x2   0x....             LDR.N    R1,??DataTable9
   \        0x4   0x....             LDR.N    R4,??DataTable9_1  ;; 0x400b8000
   \        0x6   0x600C             STR      R4,[R1, #+0]
     77            ftm1_init_struct.FTM_Mode = FTM_MODE_QD;       //使能输入捕获模式
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x7108             STRB     R0,[R1, #+4]
     78            ftm1_init_struct.FTM_QdMode = QD_MODE_CNTDIR;    //计数和方向解码模式
   \        0xC   0x2008             MOVS     R0,#+8
   \        0xE   0x7488             STRB     R0,[R1, #+18]
     79            //初始化FTM
     80            LPLD_FTM_Init(ftm1_init_struct);
   \       0x10   0xB084             SUB      SP,SP,#+16
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x221C             MOVS     R2,#+28
   \       0x16   0x....'....        BL       __aeabi_memcpy4
   \       0x1A   0xBC0F             POP      {R0-R3}
   \       0x1C   0x....'....        BL       LPLD_FTM_Init
     81            //PTB0引脚接A相输入、PTB1引脚接B相输入
     82            LPLD_FTM_QD_Enable(FTM2, PTB18, PTB19);
   \       0x20   0x2233             MOVS     R2,#+51
   \       0x22   0x2132             MOVS     R1,#+50
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x....'....        BL       LPLD_FTM_QD_Enable
     83            
     84          }
   \       0x2A   0xBD1F             POP      {R0-R4,PC}       ;; return
     85          
     86          
     87          /*********************************
     88          编码器L2
     89          **********************************/ 

   \                                 In section .text, align 2, keep-with-next
     90          void L2_init(void)
     91          {
   \                     L2_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     92            
     93                gpio_init_struct.GPIO_PTx = PTA;
   \        0x2   0x....             LDR.N    R4,??DataTable9_2
   \        0x4   0x....             LDR.N    R5,??DataTable9_3  ;; 0x400ff000
   \        0x6   0x6025             STR      R5,[R4, #+0]
     94            gpio_init_struct.GPIO_Dir =DIR_INPUT;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x7320             STRB     R0,[R4, #+12]
     95            gpio_init_struct.GPIO_PinControl = INPUT_PULL_UP;
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0x60A0             STR      R0,[R4, #+8]
     96            gpio_init_struct.GPIO_Pins = GPIO_Pin8;     //A8 判断正反转
   \       0x10   0xF44F 0x7080      MOV      R0,#+256
   \       0x14   0x6060             STR      R0,[R4, #+4]
     97            LPLD_GPIO_Init(gpio_init_struct);
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xB084             SUB      SP,SP,#+16
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x2214             MOVS     R2,#+20
   \       0x1E   0x....'....        BL       __aeabi_memcpy4
   \       0x22   0xBC0F             POP      {R0-R3}
   \       0x24   0x....'....        BL       LPLD_GPIO_Init
     98            
     99              gpio_init_struct.GPIO_PTx = PTA;
   \       0x28   0x6025             STR      R5,[R4, #+0]
    100            gpio_init_struct.GPIO_Dir =DIR_INPUT;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x7320             STRB     R0,[R4, #+12]
    101            gpio_init_struct.GPIO_PinControl = INPUT_PULL_DOWN|IRQC_RI;//自拉低
   \       0x2E   0x....             LDR.N    R0,??DataTable9_4  ;; 0x90002
   \       0x30   0x60A0             STR      R0,[R4, #+8]
    102            gpio_init_struct.GPIO_Pins = GPIO_Pin9;
   \       0x32   0xF44F 0x7000      MOV      R0,#+512
   \       0x36   0x6060             STR      R0,[R4, #+4]
    103            gpio_init_struct.GPIO_Isr=porta_isr;//中断函数 gpio_interrupt
   \       0x38   0x....'....        ADR.W    R0,porta_isr
   \       0x3C   0x6120             STR      R0,[R4, #+16]
    104            flag = LPLD_GPIO_Init(gpio_init_struct);
   \       0x3E   0x0021             MOVS     R1,R4
   \       0x40   0xB084             SUB      SP,SP,#+16
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x2214             MOVS     R2,#+20
   \       0x46   0x....'....        BL       __aeabi_memcpy4
   \       0x4A   0xBC0F             POP      {R0-R3}
   \       0x4C   0x....'....        BL       LPLD_GPIO_Init
   \       0x50   0x....             LDR.N    R1,??DataTable9_5
   \       0x52   0x6008             STR      R0,[R1, #+0]
    105            flag1 = LPLD_GPIO_EnableIrq(gpio_init_struct);//使能中断
   \       0x54   0x0021             MOVS     R1,R4
   \       0x56   0xB084             SUB      SP,SP,#+16
   \       0x58   0x4668             MOV      R0,SP
   \       0x5A   0x2214             MOVS     R2,#+20
   \       0x5C   0x....'....        BL       __aeabi_memcpy4
   \       0x60   0xBC0F             POP      {R0-R3}
   \       0x62   0x....'....        BL       LPLD_GPIO_EnableIrq
   \       0x66   0x....             LDR.N    R1,??DataTable9_6
   \       0x68   0x6008             STR      R0,[R1, #+0]
    106          }
   \       0x6A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    107          
    108          
    109          /*********************************
    110          编码器R2
    111          **********************************/ 

   \                                 In section .text, align 2, keep-with-next
    112          void R2_init(void)
    113          {
   \                     R2_init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    114            
    115            //配置正交解码功能参数
    116            ftm1_init_struct.FTM_Ftmx = FTM1;              //只有FTM1和FTM2有正交解码功能
   \        0x2   0x....             LDR.N    R1,??DataTable9
   \        0x4   0x....             LDR.N    R4,??DataTable9_7  ;; 0x40039000
   \        0x6   0x600C             STR      R4,[R1, #+0]
    117            ftm1_init_struct.FTM_Mode = FTM_MODE_QD;       //使能输入捕获模式
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x7108             STRB     R0,[R1, #+4]
    118            ftm1_init_struct.FTM_QdMode = QD_MODE_CNTDIR;    //计数和方向解码模式
   \        0xC   0x2008             MOVS     R0,#+8
   \        0xE   0x7488             STRB     R0,[R1, #+18]
    119            //初始化FTM
    120            LPLD_FTM_Init(ftm1_init_struct);
   \       0x10   0xB084             SUB      SP,SP,#+16
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x221C             MOVS     R2,#+28
   \       0x16   0x....'....        BL       __aeabi_memcpy4
   \       0x1A   0xBC0F             POP      {R0-R3}
   \       0x1C   0x....'....        BL       LPLD_FTM_Init
    121            //PTB0引脚接A相输入、PTB1引脚接B相输入
    122            LPLD_FTM_QD_Enable(FTM1, PTB0, PTB1);
   \       0x20   0x2221             MOVS     R2,#+33
   \       0x22   0x2120             MOVS     R1,#+32
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x....'....        BL       LPLD_FTM_QD_Enable
    123            
    124          
    125            
    126          }
   \       0x2A   0xBD1F             POP      {R0-R4,PC}       ;; return
    127          
    128          
    129          
    130          /*********************************
    131          编码器L1
    132          **********************************/ 
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void L1_init(void)
    135          {
   \                     L1_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    136            lptmr_init_structure.LPTMR_Mode = LPTMR_MODE_PLACC;
   \        0x2   0x....             LDR.N    R0,??DataTable9_8
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x7001             STRB     R1,[R0, #+0]
    137            lptmr_init_structure.LPTMR_PluseAccInput = LPTMR_ALT1;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x7101             STRB     R1,[R0, #+4]
    138            lptmr_init_structure.LPTMR_Isr = NULL;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6081             STR      R1,[R0, #+8]
    139            LPLD_LPTMR_Init(lptmr_init_structure); 
   \       0x10   0xC807             LDM      R0,{R0-R2}
   \       0x12   0x....'....        BL       LPLD_LPTMR_Init
    140            //初始化IO口
    141            gpio_init_struct.GPIO_PTx = PTC;
   \       0x16   0x....             LDR.N    R1,??DataTable9_2
   \       0x18   0x....             LDR.N    R0,??DataTable9_9  ;; 0x400ff080
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    142            gpio_init_struct.GPIO_Dir =DIR_INPUT;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x7308             STRB     R0,[R1, #+12]
    143            gpio_init_struct.GPIO_PinControl = INPUT_PULL_UP;
   \       0x20   0x2003             MOVS     R0,#+3
   \       0x22   0x6088             STR      R0,[R1, #+8]
    144            gpio_init_struct.GPIO_Pins = GPIO_Pin5;
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x6048             STR      R0,[R1, #+4]
    145            LPLD_GPIO_Init(gpio_init_struct);
   \       0x28   0xB084             SUB      SP,SP,#+16
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x2214             MOVS     R2,#+20
   \       0x2E   0x....'....        BL       __aeabi_memcpy4
   \       0x32   0xBC0F             POP      {R0-R3}
   \       0x34   0x....'....        BL       LPLD_GPIO_Init
    146          }
   \       0x38   0xBD01             POP      {R0,PC}          ;; return
    147          

   \                                 In section .text, align 2, keep-with-next
    148          int getspeed()
    149          {
    150            int val=0;
   \                     getspeed: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    151            val=10*gpioSpeed;
   \        0x2   0x....             LDR.N    R3,??DataTable9_10
   \        0x4   0x681A             LDR      R2,[R3, #+0]
   \        0x6   0x200A             MOVS     R0,#+10
   \        0x8   0x4342             MULS     R2,R0,R2
    152            gpioSpeed=0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6018             STR      R0,[R3, #+0]
    153            if(1==PTA8_I)
   \        0xE   0x....             LDR.N    R0,??DataTable9_11  ;; 0x43fe0220
   \       0x10   0x6803             LDR      R3,[R0, #+0]
   \       0x12   0x2B01             CMP      R3,#+1
   \       0x14   0xD102             BNE.N    ??getspeed_0
    154            {return -val;}
   \       0x16   0x4252             RSBS     R2,R2,#+0
   \       0x18   0x0010             MOVS     R0,R2
   \       0x1A   0xE005             B.N      ??getspeed_1
    155            else if(0==PTA8_I)
   \                     ??getspeed_0: (+1)
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??getspeed_2
    156            {return val;}
   \       0x22   0x0010             MOVS     R0,R2
   \       0x24   0xE000             B.N      ??getspeed_1
    157            return 0;
   \                     ??getspeed_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??getspeed_1: (+1)
   \       0x28   0x4770             BX       LR               ;; return
    158          }
    159          

   \                                 In section .text, align 2, keep-with-next
    160          int right_getSpeed()
    161          {
   \                     right_getSpeed: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    162            int16 val=0;
   \        0x2   0x2400             MOVS     R4,#+0
    163            val=10*LPLD_LPTMR_GetPulseAcc();
   \        0x4   0x....'....        BL       LPLD_LPTMR_GetPulseAcc
   \        0x8   0x210A             MOVS     R1,#+10
   \        0xA   0xFB10 0xF501      SMULBB   R5,R0,R1
    164            LPLD_LPTMR_ResetCounter();
   \        0xE   0x....'....        BL       LPLD_LPTMR_ResetCounter
    165            LPLD_LPTMR_Init(lptmr_init_structure);
   \       0x12   0x....             LDR.N    R0,??DataTable9_8
   \       0x14   0xC807             LDM      R0,{R0-R2}
   \       0x16   0x....'....        BL       LPLD_LPTMR_Init
    166            if(1==PTC5_I)
   \       0x1A   0x....             LDR.N    R0,??DataTable9_12  ;; 0x43fe1214
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD102             BNE.N    ??right_getSpeed_0
    167            {return val;}
   \       0x22   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0xE007             B.N      ??right_getSpeed_1
    168            else if(0==PTC5_I)
   \                     ??right_getSpeed_0: (+1)
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD103             BNE.N    ??right_getSpeed_2
    169            {return -val;}
   \       0x2E   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \       0x30   0x426D             RSBS     R5,R5,#+0
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xE000             B.N      ??right_getSpeed_1
    170            return 0;
   \                     ??right_getSpeed_2: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??right_getSpeed_1: (+1)
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          int ftm1_getSpeed()
    174          {
   \                     ftm1_getSpeed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    175            
    176            int16 val=0;
   \        0x2   0x2400             MOVS     R4,#+0
    177            val=10*LPLD_FTM_GetCounter(FTM1);
   \        0x4   0x....             LDR.N    R6,??DataTable9_7  ;; 0x40039000
   \        0x6   0x0030             MOVS     R0,R6
   \        0x8   0x....'....        BL       LPLD_FTM_GetCounter
   \        0xC   0x210A             MOVS     R1,#+10
   \        0xE   0xFB10 0xF501      SMULBB   R5,R0,R1
    178            LPLD_FTM_ClearCounter(FTM1);
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x....'....        BL       LPLD_FTM_ClearCounter
    179            return -val;
   \       0x18   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \       0x1A   0x426D             RSBS     R5,R5,#+0
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xBD70             POP      {R4-R6,PC}       ;; return
    180          }
    181          

   \                                 In section .text, align 2, keep-with-next
    182          int ftm2_getSpeed()
    183          {
   \                     ftm2_getSpeed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    184            
    185            int16 val=0;
   \        0x2   0x2400             MOVS     R4,#+0
    186            val=10*LPLD_FTM_GetCounter(FTM2);
   \        0x4   0x....             LDR.N    R6,??DataTable9_1  ;; 0x400b8000
   \        0x6   0x0030             MOVS     R0,R6
   \        0x8   0x....'....        BL       LPLD_FTM_GetCounter
   \        0xC   0x210A             MOVS     R1,#+10
   \        0xE   0xFB10 0xF501      SMULBB   R5,R0,R1
    187            LPLD_FTM_ClearCounter(FTM2);
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x....'....        BL       LPLD_FTM_ClearCounter
    188            return val;
   \       0x18   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xBD70             POP      {R4-R6,PC}       ;; return
    189          }
    190          

   \                                 In section .text, align 4, keep-with-next
    191          void porta_isr()
    192          {
    193           // if(LPLD_GPIO_IsPinxExt(PORTA,GPIO_Pin9)>0)
    194           // {
    195             gpioSpeed++;
   \                     porta_isr: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable9_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0x6001             STR      R1,[R0, #+0]
    196          
    197            //  LPLD_GPIO_ClearIntFlag(PORTA);
    198           // }
    199            //PTA_9=0;
    200          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ftm1_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x400B'8000        DC32     0x400b8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     gpio_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x400F'F000        DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x0009'0002        DC32     0x90002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x....'....        DC32     flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x....'....        DC32     flag1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0x4003'9000        DC32     0x40039000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x....'....        DC32     lptmr_init_structure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \        0x0   0x400F'F080        DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \        0x0   0x....'....        DC32     gpioSpeed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \        0x0   0x43FE'0220        DC32     0x43fe0220

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \        0x0   0x43FE'1214        DC32     0x43fe1214
    201          
    202            
    203          
    204          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   L1_init
         8   -> LPLD_GPIO_Init
         8   -> LPLD_LPTMR_Init
        24   -> __aeabi_memcpy4
      32   L2_init
        16   -> LPLD_GPIO_EnableIrq
        16   -> LPLD_GPIO_Init
        32   -> __aeabi_memcpy4
      40   R1_init
        24   -> LPLD_FTM_Init
        24   -> LPLD_FTM_QD_Enable
        40   -> __aeabi_memcpy4
      40   R2_init
        24   -> LPLD_FTM_Init
        24   -> LPLD_FTM_QD_Enable
        40   -> __aeabi_memcpy4
       8   encorder_init
         8   -> L1_init
         8   -> L2_init
         8   -> R1_init
         8   -> R2_init
      16   ftm1_getSpeed
        16   -> LPLD_FTM_ClearCounter
        16   -> LPLD_FTM_GetCounter
      16   ftm2_getSpeed
        16   -> LPLD_FTM_ClearCounter
        16   -> LPLD_FTM_GetCounter
       0   getspeed
       0   porta_isr
      16   right_getSpeed
        16   -> LPLD_LPTMR_GetPulseAcc
        16   -> LPLD_LPTMR_Init
        16   -> LPLD_LPTMR_ResetCounter


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      58  L1_init
     108  L2_init
      44  R1_init
      44  R2_init
      20  encorder_init
       4  flag
       4  flag1
      32  ftm1_getSpeed
      28  ftm1_init_struct
      30  ftm2_getSpeed
      42  getspeed
       4  gpioSpeed
      20  gpio_init_struct
       4  l1_reSpeed
       4  l2_reSpeed
       4  left_reSpeed
      12  lptmr_init_structure
      10  porta_isr
       4  r1_reSpeed
       4  r2_reSpeed
      58  right_getSpeed
       4  right_reSpeed
       4  speed

 
 100 bytes in section .bss
 498 bytes in section .text
 
 498 bytes of CODE memory
 100 bytes of DATA memory

Errors: none
Warnings: 1
