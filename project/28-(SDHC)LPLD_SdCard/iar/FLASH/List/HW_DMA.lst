###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         02/Jul/2019  17:59:15
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_DMA.c
#    Command line =  
#        -f C:\Users\admin\AppData\Local\Temp\EW4D01.tmp
#        (G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_DMA.c -D LPLD_K60 -lCN
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -lB
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -o "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        G:\AIcar\arm\inc\c\DLib_Config_Normal.h -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\app\" -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\HW\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\DEV\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Ports\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Source\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\option\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\driver\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\descriptor\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\class\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Jay\"
#        -On -I G:\AIcar\arm\CMSIS\Core\Include\ -I
#        G:\AIcar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List\HW_DMA.lst
#    Object file  =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj\HW_DMA.o
#
###############################################################################

G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_DMA.c
      1          /**
      2           * @file HW_DMA.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief DMA底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....'....        LDR.W    R1,??DataTable19  ;; 0xe000e100
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40E             BMI.N    ??__NVIC_DisableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....'....        LDR.W    R1,??DataTable19_1  ;; 0xe000e180
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x26   0x4770             BX       LR               ;; return
     23          #include "HW_DMA.h"
     24          
     25          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     26          DMA_ISR_CALLBACK DMA_ISR[16];
   \                     DMA_ISR:
   \        0x0                      DS8 64
     27          
     28          
     29          /*
     30           * LPLD_DMA_Init
     31           * 初始化eDMA模块
     32           * 
     33           * 参数:
     34           *    dma_init_struct--eDMA初始化结构体，
     35           *                        具体定义见DMA_InitTypeDef
     36           *
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_DMA_Init(DMA_InitTypeDef dma_init_struct)
     42          {
   \                     LPLD_DMA_Init: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x6   0xB085             SUB      SP,SP,#+20
     43            uint8 chx = dma_init_struct.DMA_CHx;
   \        0x8   0xF89D 0x6038      LDRB     R6,[SP, #+56]
     44            uint8 req = dma_init_struct.DMA_Req;
   \        0xC   0xF89D 0x7039      LDRB     R7,[SP, #+57]
     45            boolean periodic_trigg = dma_init_struct.DMA_PeriodicTriggerEnable;
   \       0x10   0xF89D 0x003A      LDRB     R0,[SP, #+58]
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
     46            uint16 major_cnt = dma_init_struct.DMA_MajorLoopCnt;
   \       0x18   0xF8BD 0x803C      LDRH     R8,[SP, #+60]
     47            uint32 minor_cnt = dma_init_struct.DMA_MinorByteCnt;
   \       0x1C   0x9810             LDR      R0,[SP, #+64]
   \       0x1E   0x9004             STR      R0,[SP, #+16]
     48            uint32 src_addr = dma_init_struct.DMA_SourceAddr;
   \       0x20   0x9C11             LDR      R4,[SP, #+68]
     49            uint8 src_dsize = dma_init_struct.DMA_SourceDataSize;
   \       0x22   0xF89D 0x9048      LDRB     R9,[SP, #+72]
     50            int16 src_addroffset = dma_init_struct.DMA_SourceAddrOffset;
   \       0x26   0xF9BD 0x004A      LDRSH    R0,[SP, #+74]
   \       0x2A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     51            int32 src_lastadj = dma_init_struct.DMA_LastSourceAddrAdj;
   \       0x2E   0x9813             LDR      R0,[SP, #+76]
   \       0x30   0x9003             STR      R0,[SP, #+12]
     52            uint32 dst_addr = dma_init_struct.DMA_DestAddr;
   \       0x32   0x9D14             LDR      R5,[SP, #+80]
     53            uint8 dst_dsize = dma_init_struct.DMA_DestDataSize;
   \       0x34   0xF89D 0xA054      LDRB     R10,[SP, #+84]
     54            int16 dst_addroffset = dma_init_struct.DMA_DestAddrOffset;
   \       0x38   0xF9BD 0x0056      LDRSH    R0,[SP, #+86]
   \       0x3C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
     55            int32 dst_lastadj = dma_init_struct.DMA_LastDestAddrAdj;
   \       0x40   0x9816             LDR      R0,[SP, #+88]
   \       0x42   0x9002             STR      R0,[SP, #+8]
     56            boolean auto_disable = dma_init_struct.DMA_AutoDisableReq;
   \       0x44   0xF89D 0xB05C      LDRB     R11,[SP, #+92]
     57            
     58            //参数检查
     59            ASSERT( chx <= DMA_CH15 );       //eDMA通道选择
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4C   0x2810             CMP      R0,#+16
   \       0x4E   0xDB04             BLT.N    ??LPLD_DMA_Init_0
   \       0x50   0x213B             MOVS     R1,#+59
   \       0x52   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x56   0x....'....        BL       assert_failed
     60            ASSERT( req <= DMA_MUX_63 );     //请求源选择
   \                     ??LPLD_DMA_Init_0: (+1)
   \       0x5A   0x0038             MOVS     R0,R7
   \       0x5C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x5E   0x2840             CMP      R0,#+64
   \       0x60   0xDB04             BLT.N    ??LPLD_DMA_Init_1
   \       0x62   0x213C             MOVS     R1,#+60
   \       0x64   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x68   0x....'....        BL       assert_failed
     61            ASSERT( major_cnt <= 0x7FFF );   //主计数判断
   \                     ??LPLD_DMA_Init_1: (+1)
   \       0x6C   0x4640             MOV      R0,R8
   \       0x6E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x70   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x74   0xDB04             BLT.N    ??LPLD_DMA_Init_2
   \       0x76   0x213D             MOVS     R1,#+61
   \       0x78   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x7C   0x....'....        BL       assert_failed
     62            ASSERT( src_addr != NULL );      //源地址判断
   \                     ??LPLD_DMA_Init_2: (+1)
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD104             BNE.N    ??LPLD_DMA_Init_3
   \       0x84   0x213E             MOVS     R1,#+62
   \       0x86   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x8A   0x....'....        BL       assert_failed
     63            ASSERT( (src_dsize <= DMA_SRC_32BIT)||(src_dsize == DMA_SRC_16BYTE) );     //源数据传输大小判断
   \                     ??LPLD_DMA_Init_3: (+1)
   \       0x8E   0x4648             MOV      R0,R9
   \       0x90   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x92   0x2803             CMP      R0,#+3
   \       0x94   0xDB08             BLT.N    ??LPLD_DMA_Init_4
   \       0x96   0x4648             MOV      R0,R9
   \       0x98   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x9A   0x2804             CMP      R0,#+4
   \       0x9C   0xD004             BEQ.N    ??LPLD_DMA_Init_4
   \       0x9E   0x213F             MOVS     R1,#+63
   \       0xA0   0x....'....        LDR.W    R0,??DataTable19_2
   \       0xA4   0x....'....        BL       assert_failed
     64            ASSERT( dst_addr != NULL );      //目的地址判断
   \                     ??LPLD_DMA_Init_4: (+1)
   \       0xA8   0x2D00             CMP      R5,#+0
   \       0xAA   0xD104             BNE.N    ??LPLD_DMA_Init_5
   \       0xAC   0x2140             MOVS     R1,#+64
   \       0xAE   0x....'....        LDR.W    R0,??DataTable19_2
   \       0xB2   0x....'....        BL       assert_failed
     65            ASSERT( (dst_dsize <= DMA_DST_32BIT)||(dst_dsize == DMA_DST_16BYTE) );     //目的数据传输大小判断
   \                     ??LPLD_DMA_Init_5: (+1)
   \       0xB6   0x4650             MOV      R0,R10
   \       0xB8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xBA   0x2803             CMP      R0,#+3
   \       0xBC   0xDB07             BLT.N    ??LPLD_DMA_Init_6
   \       0xBE   0x4650             MOV      R0,R10
   \       0xC0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xC2   0x2804             CMP      R0,#+4
   \       0xC4   0xD003             BEQ.N    ??LPLD_DMA_Init_6
   \       0xC6   0x2141             MOVS     R1,#+65
   \       0xC8   0x....             LDR.N    R0,??DataTable19_2
   \       0xCA   0x....'....        BL       assert_failed
     66           
     67            SIM->SCGC6 |= SIM_SCGC6_DMAMUX_MASK;  //打开DMA通道多路复用器时钟   
   \                     ??LPLD_DMA_Init_6: (+1)
   \       0xCE   0x....             LDR.N    R0,??DataTable19_3  ;; 0x4004803c
   \       0xD0   0x6801             LDR      R1,[R0, #+0]
   \       0xD2   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0xD6   0x6001             STR      R1,[R0, #+0]
     68            SIM->SCGC7 |= SIM_SCGC7_DMA_MASK;     //打开DMA模块时钟
   \       0xD8   0x....             LDR.N    R0,??DataTable19_4  ;; 0x40048040
   \       0xDA   0x6801             LDR      R1,[R0, #+0]
   \       0xDC   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0xE0   0x6001             STR      R1,[R0, #+0]
     69            
     70            //关闭通道x硬件DMA请求 
     71            DMA0->ERQ &= ~(1<<chx);
   \       0xE2   0x....             LDR.N    R0,??DataTable19_5  ;; 0x4000800c
   \       0xE4   0x6801             LDR      R1,[R0, #+0]
   \       0xE6   0x2201             MOVS     R2,#+1
   \       0xE8   0x40B2             LSLS     R2,R2,R6
   \       0xEA   0x4391             BICS     R1,R1,R2
   \       0xEC   0x6001             STR      R1,[R0, #+0]
     72            
     73            //选择 通道x 配置外设的DMA源请求编号
     74            DMAMUX->CHCFG[chx] = DMAMUX_CHCFG_SOURCE(req);
   \       0xEE   0x....             LDR.N    R1,??DataTable19_6  ;; 0x40021000
   \       0xF0   0xF017 0x003F      ANDS     R0,R7,#0x3F
   \       0xF4   0x0032             MOVS     R2,R6
   \       0xF6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xF8   0x5488             STRB     R0,[R1, R2]
     75            //是否使能周期触发功能
     76            if(periodic_trigg == TRUE)
   \       0xFA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xFE   0x2801             CMP      R0,#+1
   \      0x100   0xD108             BNE.N    ??LPLD_DMA_Init_7
     77            {
     78              DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_TRIG_MASK;
   \      0x102   0x0030             MOVS     R0,R6
   \      0x104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x106   0x5C08             LDRB     R0,[R1, R0]
   \      0x108   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x10C   0x0032             MOVS     R2,R6
   \      0x10E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x110   0x5488             STRB     R0,[R1, R2]
   \      0x112   0xE007             B.N      ??LPLD_DMA_Init_8
     79            }
     80            else
     81            {
     82              DMAMUX->CHCFG[chx] &= ~(DMAMUX_CHCFG_TRIG_MASK);
   \                     ??LPLD_DMA_Init_7: (+1)
   \      0x114   0x0030             MOVS     R0,R6
   \      0x116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x118   0x5C08             LDRB     R0,[R1, R0]
   \      0x11A   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \      0x11E   0x0032             MOVS     R2,R6
   \      0x120   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x122   0x5488             STRB     R0,[R1, R2]
     83            }
     84            
     85            
     86            //设置源地址   
     87            DMA0->TCD[chx].SADDR = DMA_SADDR_SADDR(src_addr);
   \                     ??LPLD_DMA_Init_8: (+1)
   \      0x124   0x....             LDR.N    R2,??DataTable19_7  ;; 0x40009000
   \      0x126   0x0030             MOVS     R0,R6
   \      0x128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x12A   0x0140             LSLS     R0,R0,#+5
   \      0x12C   0x5014             STR      R4,[R2, R0]
     88            //在执行完针对源地址的操作之后，在源地址的基础上增加/减少偏移地址
     89            DMA0->TCD[chx].SOFF = DMA_SOFF_SOFF(src_addroffset);
   \      0x12E   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \      0x132   0x0033             MOVS     R3,R6
   \      0x134   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x136   0x015B             LSLS     R3,R3,#+5
   \      0x138   0x4413             ADD      R3,R2,R3
   \      0x13A   0x8098             STRH     R0,[R3, #+4]
     90            //设置源地址的传输大小
     91            DMA0->TCD[chx].ATTR = 0 | DMA_ATTR_SSIZE(src_dsize);
   \      0x13C   0x4648             MOV      R0,R9
   \      0x13E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x140   0x0200             LSLS     R0,R0,#+8
   \      0x142   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \      0x146   0x0033             MOVS     R3,R6
   \      0x148   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x14A   0x015B             LSLS     R3,R3,#+5
   \      0x14C   0x4413             ADD      R3,R2,R3
   \      0x14E   0x80D8             STRH     R0,[R3, #+6]
     92            //主的计数次数（major iteration count）达到后，重新调整源地址
     93            DMA0->TCD[chx].SLAST = DMA_SLAST_SLAST(src_lastadj);
   \      0x150   0x9803             LDR      R0,[SP, #+12]
   \      0x152   0x0033             MOVS     R3,R6
   \      0x154   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x156   0x015B             LSLS     R3,R3,#+5
   \      0x158   0x4413             ADD      R3,R2,R3
   \      0x15A   0x60D8             STR      R0,[R3, #+12]
     94            
     95            //设置目的地址 
     96            DMA0->TCD[chx].DADDR = DMA_DADDR_DADDR(dst_addr);
   \      0x15C   0x0030             MOVS     R0,R6
   \      0x15E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x160   0x0140             LSLS     R0,R0,#+5
   \      0x162   0x4410             ADD      R0,R2,R0
   \      0x164   0x6105             STR      R5,[R0, #+16]
     97            //在执行完针对目的地址的操作之后，在目的地址的基础上增加/减少偏移地址
     98            DMA0->TCD[chx].DOFF = DMA_DOFF_DOFF(dst_addroffset);
   \      0x166   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \      0x16A   0x0033             MOVS     R3,R6
   \      0x16C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x16E   0x015B             LSLS     R3,R3,#+5
   \      0x170   0x4413             ADD      R3,R2,R3
   \      0x172   0x8298             STRH     R0,[R3, #+20]
     99            //设置目的地址的传输宽度
    100            DMA0->TCD[chx].ATTR |= DMA_ATTR_DSIZE(dst_dsize);
   \      0x174   0x0030             MOVS     R0,R6
   \      0x176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x178   0x0140             LSLS     R0,R0,#+5
   \      0x17A   0x4410             ADD      R0,R2,R0
   \      0x17C   0x88C0             LDRH     R0,[R0, #+6]
   \      0x17E   0x4653             MOV      R3,R10
   \      0x180   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x182   0xF013 0x0307      ANDS     R3,R3,#0x7
   \      0x186   0x4318             ORRS     R0,R3,R0
   \      0x188   0x0033             MOVS     R3,R6
   \      0x18A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x18C   0x015B             LSLS     R3,R3,#+5
   \      0x18E   0x4413             ADD      R3,R2,R3
   \      0x190   0x80D8             STRH     R0,[R3, #+6]
    101            //主的计数次数（major iteration count）达到后，重新调整目的地址
    102            DMA0->TCD[chx].DLAST_SGA = DMA_DLAST_SGA_DLASTSGA(dst_lastadj);
   \      0x192   0x9802             LDR      R0,[SP, #+8]
   \      0x194   0x0033             MOVS     R3,R6
   \      0x196   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x198   0x015B             LSLS     R3,R3,#+5
   \      0x19A   0x4413             ADD      R3,R2,R3
   \      0x19C   0x6198             STR      R0,[R3, #+24]
    103            
    104            //默认为禁用通道链接功能，后续更新添加此功能
    105            if( 1 == 1)
    106            {
    107              //===============设置主计数器长度，循环次数====================================
    108              //设置主循环计数器 current major loop count
    109              DMA0->TCD[chx].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
   \      0x19E   0xEA5F 0x4048      LSLS     R0,R8,#+17       ;; ZeroExtS R0,R8,#+17,#+17
   \      0x1A2   0x0C40             LSRS     R0,R0,#+17
   \      0x1A4   0x0033             MOVS     R3,R6
   \      0x1A6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x1A8   0x015B             LSLS     R3,R3,#+5
   \      0x1AA   0x4413             ADD      R3,R2,R3
   \      0x1AC   0x82D8             STRH     R0,[R3, #+22]
    110              //起始循环计数器，当主循环计数器为零的时候，将装载起始循环计数器的值
    111              DMA0->TCD[chx].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
   \      0x1AE   0xEA5F 0x4048      LSLS     R0,R8,#+17       ;; ZeroExtS R0,R8,#+17,#+17
   \      0x1B2   0x0C40             LSRS     R0,R0,#+17
   \      0x1B4   0x0033             MOVS     R3,R6
   \      0x1B6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x1B8   0x015B             LSLS     R3,R3,#+5
   \      0x1BA   0x4413             ADD      R3,R2,R3
   \      0x1BC   0x83D8             STRH     R0,[R3, #+30]
    112            }
    113            
    114            //默认为禁用次循环地址偏移功能，后续更新添加此功能
    115            if( 1 == 1)
    116            {
    117              //次循环一次传输字节的个数
    118              DMA0->TCD[chx].NBYTES_MLNO = DMA_NBYTES_MLNO_NBYTES(minor_cnt);
   \      0x1BE   0x9804             LDR      R0,[SP, #+16]
   \      0x1C0   0x0033             MOVS     R3,R6
   \      0x1C2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x1C4   0x015B             LSLS     R3,R3,#+5
   \      0x1C6   0x4413             ADD      R3,R2,R3
   \      0x1C8   0x6098             STR      R0,[R3, #+8]
    119            }
    120            
    121            //清空TCD控制寄存器     
    122            DMA0->TCD[chx].CSR = 0;
   \      0x1CA   0x2000             MOVS     R0,#+0
   \      0x1CC   0x0033             MOVS     R3,R6
   \      0x1CE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x1D0   0x015B             LSLS     R3,R3,#+5
   \      0x1D2   0x4413             ADD      R3,R2,R3
   \      0x1D4   0x8398             STRH     R0,[R3, #+28]
    123            
    124            //配置eDMA中断
    125            if((dma_init_struct.DMA_Isr != NULL) && 
    126               (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
   \      0x1D6   0x9818             LDR      R0,[SP, #+96]
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD016             BEQ.N    ??LPLD_DMA_Init_9
   \      0x1DC   0xF89D 0x005D      LDRB     R0,[SP, #+93]
   \      0x1E0   0x2801             CMP      R0,#+1
   \      0x1E2   0xD112             BNE.N    ??LPLD_DMA_Init_9
    127            {
    128          
    129                 DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //使能DMA 主循环计数器减到零 中断
   \      0x1E4   0x0030             MOVS     R0,R6
   \      0x1E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1E8   0x0140             LSLS     R0,R0,#+5
   \      0x1EA   0x4410             ADD      R0,R2,R0
   \      0x1EC   0x8B80             LDRH     R0,[R0, #+28]
   \      0x1EE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x1F2   0x0033             MOVS     R3,R6
   \      0x1F4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x1F6   0x015B             LSLS     R3,R3,#+5
   \      0x1F8   0x4413             ADD      R3,R2,R3
   \      0x1FA   0x8398             STRH     R0,[R3, #+28]
    130                 DMA_ISR[chx] = dma_init_struct.DMA_Isr;
   \      0x1FC   0x9818             LDR      R0,[SP, #+96]
   \      0x1FE   0x....             LDR.N    R3,??DataTable19_8
   \      0x200   0x46B4             MOV      R12,R6
   \      0x202   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x206   0xF843 0x002C      STR      R0,[R3, R12, LSL #+2]
    131            }
    132            if((dma_init_struct.DMA_Isr != NULL) && 
    133               (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
   \                     ??LPLD_DMA_Init_9: (+1)
   \      0x20A   0x9818             LDR      R0,[SP, #+96]
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD016             BEQ.N    ??LPLD_DMA_Init_10
   \      0x210   0xF89D 0x005E      LDRB     R0,[SP, #+94]
   \      0x214   0x2801             CMP      R0,#+1
   \      0x216   0xD112             BNE.N    ??LPLD_DMA_Init_10
    134            {
    135          
    136                 DMA0->TCD[chx].CSR |= DMA_CSR_INTHALF_MASK; //使能DMA 主循环计数器减到一半 中断
   \      0x218   0x0030             MOVS     R0,R6
   \      0x21A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x21C   0x0140             LSLS     R0,R0,#+5
   \      0x21E   0x4410             ADD      R0,R2,R0
   \      0x220   0x8B80             LDRH     R0,[R0, #+28]
   \      0x222   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x226   0x0033             MOVS     R3,R6
   \      0x228   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x22A   0x015B             LSLS     R3,R3,#+5
   \      0x22C   0x4413             ADD      R3,R2,R3
   \      0x22E   0x8398             STRH     R0,[R3, #+28]
    137                 DMA_ISR[chx] = dma_init_struct.DMA_Isr;
   \      0x230   0x9818             LDR      R0,[SP, #+96]
   \      0x232   0x....             LDR.N    R3,??DataTable19_8
   \      0x234   0x46B4             MOV      R12,R6
   \      0x236   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x23A   0xF843 0x002C      STR      R0,[R3, R12, LSL #+2]
    138            }
    139              
    140            if(auto_disable == TRUE)
   \                     ??LPLD_DMA_Init_10: (+1)
   \      0x23E   0x4658             MOV      R0,R11
   \      0x240   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x242   0x2801             CMP      R0,#+1
   \      0x244   0xD10C             BNE.N    ??LPLD_DMA_Init_11
    141            {
    142               DMA0->TCD[chx].CSR |= DMA_CSR_DREQ_MASK; //主循环计数器等于零后，自动关闭DMA 
   \      0x246   0x0030             MOVS     R0,R6
   \      0x248   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x24A   0x0140             LSLS     R0,R0,#+5
   \      0x24C   0x4410             ADD      R0,R2,R0
   \      0x24E   0x8B80             LDRH     R0,[R0, #+28]
   \      0x250   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x254   0x0033             MOVS     R3,R6
   \      0x256   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \      0x258   0x015B             LSLS     R3,R3,#+5
   \      0x25A   0x441A             ADD      R2,R2,R3
   \      0x25C   0x8390             STRH     R0,[R2, #+28]
   \      0x25E   0xE00C             B.N      ??LPLD_DMA_Init_12
    143            }
    144            else
    145            {
    146               DMA0->TCD[chx].CSR &= ~(DMA_CSR_DREQ_MASK); //主循环计数器等于零后，不关闭DMA
   \                     ??LPLD_DMA_Init_11: (+1)
   \      0x260   0x0030             MOVS     R0,R6
   \      0x262   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x264   0x0140             LSLS     R0,R0,#+5
   \      0x266   0x4410             ADD      R0,R2,R0
   \      0x268   0x8B83             LDRH     R3,[R0, #+28]
   \      0x26A   0xF64F 0x70F7      MOVW     R0,#+65527
   \      0x26E   0x4003             ANDS     R3,R0,R3
   \      0x270   0x0030             MOVS     R0,R6
   \      0x272   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x274   0x0140             LSLS     R0,R0,#+5
   \      0x276   0x4410             ADD      R0,R2,R0
   \      0x278   0x8383             STRH     R3,[R0, #+28]
    147            } 
    148           
    149            //DMA通道使能
    150            DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_ENBL_MASK;
   \                     ??LPLD_DMA_Init_12: (+1)
   \      0x27A   0x0030             MOVS     R0,R6
   \      0x27C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x27E   0x5C08             LDRB     R0,[R1, R0]
   \      0x280   0xF050 0x0080      ORRS     R0,R0,#0x80
   \      0x284   0x0032             MOVS     R2,R6
   \      0x286   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \      0x288   0x5488             STRB     R0,[R1, R2]
    151              
    152            return 1;
   \      0x28A   0x2001             MOVS     R0,#+1
   \      0x28C   0xB005             ADD      SP,SP,#+20
   \      0x28E   0xE8BD 0x0FF0      POP      {R4-R11}
   \      0x292   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    153          }
    154          
    155          /*
    156           * LPLD_DMA_EnableIrq
    157           * 使能eDMA中断
    158           * 
    159           * 参数:
    160           *    dma_init_struct--eDMA初始化结构体，
    161           *                        具体定义见DMA_InitTypeDef
    162           *
    163           * 输出:
    164           *    0--失败
    165           *    1--成功
    166           */

   \                                 In section .text, align 2, keep-with-next
    167          uint8 LPLD_DMA_EnableIrq(DMA_InitTypeDef dma_init_struct)
    168          {
   \                     LPLD_DMA_EnableIrq: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
    169            enable_irq((IRQn_Type)(dma_init_struct.DMA_CHx + DMA0_IRQn));  
   \        0x4   0xF99D 0x0008      LDRSB    R0,[SP, #+8]
   \        0x8   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \        0xA   0x....'....        BL       __NVIC_EnableIRQ
    170            return 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBC02             POP      {R1}
   \       0x12   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    171          }
    172          
    173          /*
    174           * LPLD_DMA_DisableIrq
    175           * 禁用eDMA中断
    176           * 
    177           * 参数:
    178           *    dma_init_struct--eDMA初始化结构体，
    179           *                        具体定义见DMA_InitTypeDef
    180           *
    181           * 输出:
    182           *    0--失败
    183           *    1--成功
    184           */

   \                                 In section .text, align 2, keep-with-next
    185          uint8 LPLD_DMA_DisableIrq(DMA_InitTypeDef dma_init_struct)
    186          {
   \                     LPLD_DMA_DisableIrq: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
    187            disable_irq((IRQn_Type)(dma_init_struct.DMA_CHx + DMA0_IRQn));
   \        0x4   0xF99D 0x0008      LDRSB    R0,[SP, #+8]
   \        0x8   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \        0xA   0x....'....        BL       __NVIC_DisableIRQ
    188            return 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBC02             POP      {R1}
   \       0x12   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    189          }
    190          
    191          /*
    192           * LPLD_DMA_SoftwareStartService
    193           * DMA服务请求软件开始
    194           * 
    195           * 参数:
    196           *    dma_init_struct--eDMA初始化结构体，
    197           *                        具体定义见DMA_InitTypeDef
    198           *
    199           * 输出:
    200           *    无
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          __INLINE void LPLD_DMA_SoftwareStartService(DMA_InitTypeDef dma_init_struct)
    203          {
   \                     LPLD_DMA_SoftwareStartService: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
    204            DMA0->TCD[dma_init_struct.DMA_CHx].CSR |= DMA_CSR_START_MASK; 
   \        0x2   0x....             LDR.N    R0,??DataTable19_7  ;; 0x40009000
   \        0x4   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \        0x8   0x0149             LSLS     R1,R1,#+5
   \        0xA   0x4401             ADD      R1,R0,R1
   \        0xC   0x8B89             LDRH     R1,[R1, #+28]
   \        0xE   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x12   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0x16   0x0152             LSLS     R2,R2,#+5
   \       0x18   0x4410             ADD      R0,R0,R2
   \       0x1A   0x8381             STRH     R1,[R0, #+28]
    205          }
   \       0x1C   0xB004             ADD      SP,SP,#+16
   \       0x1E   0x4770             BX       LR               ;; return
    206          
    207          /*
    208           * eDMA中断处理函数
    209           * 与启动文件startup_K60.s中的中断向量表关联
    210           * 用户无需修改，程序自动进入对应通道中断函数
    211           */

   \                                 In section .text, align 2, keep-with-next
    212          void DMA0_IRQHandler(void)
    213          {
   \                     DMA0_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    214          #if (UCOS_II > 0u)
    215            OS_CPU_SR  cpu_sr = 0u;
    216            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    217            OSIntEnter();
    218            OS_EXIT_CRITICAL();
    219          #endif  
    220            
    221            //调用用户自定义中断服务
    222            DMA_ISR[0]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4780             BLX      R0
    223            //清除中断标志位
    224            DMA0->INT |= 0x1u<<0;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x6001             STR      R1,[R0, #+0]
    225            
    226          #if (UCOS_II > 0u)
    227            OSIntExit();          //告知系统此时即将离开中断服务子函数
    228          #endif
    229          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    230          

   \                                 In section .text, align 2, keep-with-next
    231          void DMA1_IRQHandler(void)
    232          {
   \                     DMA1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    233          #if (UCOS_II > 0u)
    234            OS_CPU_SR  cpu_sr = 0u;
    235            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    236            OSIntEnter();
    237            OS_EXIT_CRITICAL();
    238          #endif  
    239            
    240            //调用用户自定义中断服务
    241            DMA_ISR[1]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6840             LDR      R0,[R0, #+4]
   \        0x6   0x4780             BLX      R0
    242            //清除中断标志位
    243            DMA0->INT |= 0x1u<<1;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x10   0x6001             STR      R1,[R0, #+0]
    244            
    245          #if (UCOS_II > 0u)
    246            OSIntExit();          //告知系统此时即将离开中断服务子函数
    247          #endif
    248          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void DMA2_IRQHandler(void)
    251          {
   \                     DMA2_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    252          #if (UCOS_II > 0u)
    253            OS_CPU_SR  cpu_sr = 0u;
    254            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    255            OSIntEnter();
    256            OS_EXIT_CRITICAL();
    257          #endif  
    258            
    259            //调用用户自定义中断服务
    260            DMA_ISR[2]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6880             LDR      R0,[R0, #+8]
   \        0x6   0x4780             BLX      R0
    261            //清除中断标志位
    262            DMA0->INT |= 0x1u<<2;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x10   0x6001             STR      R1,[R0, #+0]
    263            
    264          #if (UCOS_II > 0u)
    265            OSIntExit();          //告知系统此时即将离开中断服务子函数
    266          #endif
    267          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void DMA3_IRQHandler(void)
    270          {
   \                     DMA3_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    271          #if (UCOS_II > 0u)
    272            OS_CPU_SR  cpu_sr = 0u;
    273            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    274            OSIntEnter();
    275            OS_EXIT_CRITICAL();
    276          #endif  
    277            
    278            //调用用户自定义中断服务
    279            DMA_ISR[3]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x68C0             LDR      R0,[R0, #+12]
   \        0x6   0x4780             BLX      R0
    280            //清除中断标志位
    281            DMA0->INT |= 0x1u<<3;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x10   0x6001             STR      R1,[R0, #+0]
    282            
    283          #if (UCOS_II > 0u)
    284            OSIntExit();          //告知系统此时即将离开中断服务子函数
    285          #endif
    286          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    287          

   \                                 In section .text, align 2, keep-with-next
    288          void DMA4_IRQHandler(void)
    289          {
   \                     DMA4_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    290          #if (UCOS_II > 0u)
    291            OS_CPU_SR  cpu_sr = 0u;
    292            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    293            OSIntEnter();
    294            OS_EXIT_CRITICAL();
    295          #endif  
    296            
    297            //调用用户自定义中断服务
    298            DMA_ISR[4]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6900             LDR      R0,[R0, #+16]
   \        0x6   0x4780             BLX      R0
    299            //清除中断标志位
    300            DMA0->INT |= 0x1u<<4;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x10   0x6001             STR      R1,[R0, #+0]
    301            
    302          #if (UCOS_II > 0u)
    303            OSIntExit();          //告知系统此时即将离开中断服务子函数
    304          #endif
    305          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    306          

   \                                 In section .text, align 2, keep-with-next
    307          void DMA5_IRQHandler(void)
    308          {
   \                     DMA5_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    309          #if (UCOS_II > 0u)
    310            OS_CPU_SR  cpu_sr = 0u;
    311            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    312            OSIntEnter();
    313            OS_EXIT_CRITICAL();
    314          #endif  
    315            
    316            //调用用户自定义中断服务
    317            DMA_ISR[5]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6940             LDR      R0,[R0, #+20]
   \        0x6   0x4780             BLX      R0
    318            //清除中断标志位
    319            DMA0->INT |= 0x1u<<5;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x10   0x6001             STR      R1,[R0, #+0]
    320            
    321          #if (UCOS_II > 0u)
    322            OSIntExit();          //告知系统此时即将离开中断服务子函数
    323          #endif
    324          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    325          

   \                                 In section .text, align 2, keep-with-next
    326          void DMA6_IRQHandler(void)
    327          {
   \                     DMA6_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    328          #if (UCOS_II > 0u)
    329            OS_CPU_SR  cpu_sr = 0u;
    330            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    331            OSIntEnter();
    332            OS_EXIT_CRITICAL();
    333          #endif  
    334            
    335            //调用用户自定义中断服务
    336            DMA_ISR[6]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6980             LDR      R0,[R0, #+24]
   \        0x6   0x4780             BLX      R0
    337            //清除中断标志位
    338            DMA0->INT |= 0x1u<<6;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x10   0x6001             STR      R1,[R0, #+0]
    339            
    340          #if (UCOS_II > 0u)
    341            OSIntExit();          //告知系统此时即将离开中断服务子函数
    342          #endif
    343          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    344          

   \                                 In section .text, align 2, keep-with-next
    345          void DMA7_IRQHandler(void)
    346          {
   \                     DMA7_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    347          #if (UCOS_II > 0u)
    348            OS_CPU_SR  cpu_sr = 0u;
    349            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    350            OSIntEnter();
    351            OS_EXIT_CRITICAL();
    352          #endif  
    353            
    354            //调用用户自定义中断服务
    355            DMA_ISR[7]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x69C0             LDR      R0,[R0, #+28]
   \        0x6   0x4780             BLX      R0
    356            //清除中断标志位
    357            DMA0->INT |= 0x1u<<7;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x10   0x6001             STR      R1,[R0, #+0]
    358            
    359          #if (UCOS_II > 0u)
    360            OSIntExit();          //告知系统此时即将离开中断服务子函数
    361          #endif
    362          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    363          

   \                                 In section .text, align 2, keep-with-next
    364          void DMA8_IRQHandler(void)
    365          {
   \                     DMA8_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    366          #if (UCOS_II > 0u)
    367            OS_CPU_SR  cpu_sr = 0u;
    368            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    369            OSIntEnter();
    370            OS_EXIT_CRITICAL();
    371          #endif  
    372            
    373            //调用用户自定义中断服务
    374            DMA_ISR[8]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6A00             LDR      R0,[R0, #+32]
   \        0x6   0x4780             BLX      R0
    375            //清除中断标志位
    376            DMA0->INT |= 0x1u<<8;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x10   0x6001             STR      R1,[R0, #+0]
    377            
    378          #if (UCOS_II > 0u)
    379            OSIntExit();          //告知系统此时即将离开中断服务子函数
    380          #endif
    381          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void DMA9_IRQHandler(void)
    384          {
   \                     DMA9_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    385          #if (UCOS_II > 0u)
    386            OS_CPU_SR  cpu_sr = 0u;
    387            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    388            OSIntEnter();
    389            OS_EXIT_CRITICAL();
    390          #endif  
    391            
    392            //调用用户自定义中断服务
    393            DMA_ISR[9]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6A40             LDR      R0,[R0, #+36]
   \        0x6   0x4780             BLX      R0
    394            //清除中断标志位
    395            DMA0->INT |= 0x1u<<9;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x10   0x6001             STR      R1,[R0, #+0]
    396            
    397          #if (UCOS_II > 0u)
    398            OSIntExit();          //告知系统此时即将离开中断服务子函数
    399          #endif
    400          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    401          

   \                                 In section .text, align 2, keep-with-next
    402          void DMA10_IRQHandler(void)
    403          {
   \                     DMA10_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    404          #if (UCOS_II > 0u)
    405            OS_CPU_SR  cpu_sr = 0u;
    406            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    407            OSIntEnter();
    408            OS_EXIT_CRITICAL();
    409          #endif  
    410            
    411            //调用用户自定义中断服务
    412            DMA_ISR[10]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6A80             LDR      R0,[R0, #+40]
   \        0x6   0x4780             BLX      R0
    413            //清除中断标志位
    414            DMA0->INT |= 0x1u<10;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x6001             STR      R1,[R0, #+0]
    415            
    416          #if (UCOS_II > 0u)
    417            OSIntExit();          //告知系统此时即将离开中断服务子函数
    418          #endif
    419          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    420          

   \                                 In section .text, align 2, keep-with-next
    421          void DMA11_IRQHandler(void)
    422          {
   \                     DMA11_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    423          #if (UCOS_II > 0u)
    424            OS_CPU_SR  cpu_sr = 0u;
    425            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    426            OSIntEnter();
    427            OS_EXIT_CRITICAL();
    428          #endif  
    429            
    430            //调用用户自定义中断服务
    431            DMA_ISR[11]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6AC0             LDR      R0,[R0, #+44]
   \        0x6   0x4780             BLX      R0
    432            //清除中断标志位
    433            DMA0->INT |= 0x1u<<11;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x10   0x6001             STR      R1,[R0, #+0]
    434            
    435          #if (UCOS_II > 0u)
    436            OSIntExit();          //告知系统此时即将离开中断服务子函数
    437          #endif
    438          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void DMA12_IRQHandler(void)
    441          {
   \                     DMA12_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    442          #if (UCOS_II > 0u)
    443            OS_CPU_SR  cpu_sr = 0u;
    444            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    445            OSIntEnter();
    446            OS_EXIT_CRITICAL();
    447          #endif  
    448            
    449            //调用用户自定义中断服务
    450            DMA_ISR[12]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6B00             LDR      R0,[R0, #+48]
   \        0x6   0x4780             BLX      R0
    451            //清除中断标志位
    452            DMA0->INT |= 0x1u<<12;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \       0x10   0x6001             STR      R1,[R0, #+0]
    453            
    454          #if (UCOS_II > 0u)
    455            OSIntExit();          //告知系统此时即将离开中断服务子函数
    456          #endif
    457          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    458          

   \                                 In section .text, align 2, keep-with-next
    459          void DMA13_IRQHandler(void)
    460          {
   \                     DMA13_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    461          #if (UCOS_II > 0u)
    462            OS_CPU_SR  cpu_sr = 0u;
    463            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    464            OSIntEnter();
    465            OS_EXIT_CRITICAL();
    466          #endif  
    467            
    468            //调用用户自定义中断服务
    469            DMA_ISR[13]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6B40             LDR      R0,[R0, #+52]
   \        0x6   0x4780             BLX      R0
    470            //清除中断标志位
    471            DMA0->INT |= 0x1u<<13;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \       0x10   0x6001             STR      R1,[R0, #+0]
    472            
    473          #if (UCOS_II > 0u)
    474            OSIntExit();          //告知系统此时即将离开中断服务子函数
    475          #endif
    476          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    477          

   \                                 In section .text, align 2, keep-with-next
    478          void DMA14_IRQHandler(void)
    479          {
   \                     DMA14_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    480          #if (UCOS_II > 0u)
    481            OS_CPU_SR  cpu_sr = 0u;
    482            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    483            OSIntEnter();
    484            OS_EXIT_CRITICAL();
    485          #endif  
    486            
    487            //调用用户自定义中断服务
    488            DMA_ISR[14]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6B80             LDR      R0,[R0, #+56]
   \        0x6   0x4780             BLX      R0
    489            //清除中断标志位
    490            DMA0->INT |= 0x1u<<14;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x10   0x6001             STR      R1,[R0, #+0]
    491            
    492          #if (UCOS_II > 0u)
    493            OSIntExit();          //告知系统此时即将离开中断服务子函数
    494          #endif
    495          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    496          

   \                                 In section .text, align 2, keep-with-next
    497          void DMA15_IRQHandler(void)
    498          {
   \                     DMA15_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    499          #if (UCOS_II > 0u)
    500            OS_CPU_SR  cpu_sr = 0u;
    501            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    502            OSIntEnter();
    503            OS_EXIT_CRITICAL();
    504          #endif  
    505            
    506            //调用用户自定义中断服务
    507            DMA_ISR[15]();
   \        0x2   0x....             LDR.N    R0,??DataTable19_8
   \        0x4   0x6BC0             LDR      R0,[R0, #+60]
   \        0x6   0x4780             BLX      R0
    508            //清除中断标志位
    509            DMA0->INT |= 0x1u<<15;
   \        0x8   0x....             LDR.N    R0,??DataTable19_9  ;; 0x40008024
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \       0x10   0x6001             STR      R1,[R0, #+0]
    510            
    511          #if (UCOS_II > 0u)
    512            OSIntExit();          //告知系统此时即将离开中断服务子函数
    513          #endif
    514          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x4004'803C        DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x4004'8040        DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \        0x0   0x4000'800C        DC32     0x4000800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \        0x0   0x4000'9000        DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \        0x0   0x....'....        DC32     DMA_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \        0x0   0x4000'8024        DC32     0x40008024

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x47 0x3A          DC8 "G:\\AIcar\\\344\277\241\346\240\207\\xiugai\\lib\\LPLD\\HW\\HW_DMA.c"
   \              0x5C 0x41    
   \              0x49 0x63    
   \              0x61 0x72    
   \              0x5C 0xE4    
   \              0xBF 0xA1    
   \              0xE6 0xA0    
   \              0x87 0x5C    
   \              0x78 0x69    
   \              0x75 0x67    
   \              0x61 0x69    
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \              0x50 0x4C    
   \              0x44 0x5C    
   \              0x48 0x57    
   \              0x5C 0x48    
   \              0x57 0x5F    
   \              0x44 0x4D    
   \              0x41 0x2E    
   \              0x63 0x00    
    515          
    516          
    517          
    518          
    519          
    520          
    521          
    522          
    523          
    524          
    525          
    526          
    527          
    528          
    529          
    530          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA0_IRQHandler
         8   -- Indirect call
       8   DMA10_IRQHandler
         8   -- Indirect call
       8   DMA11_IRQHandler
         8   -- Indirect call
       8   DMA12_IRQHandler
         8   -- Indirect call
       8   DMA13_IRQHandler
         8   -- Indirect call
       8   DMA14_IRQHandler
         8   -- Indirect call
       8   DMA15_IRQHandler
         8   -- Indirect call
       8   DMA1_IRQHandler
         8   -- Indirect call
       8   DMA2_IRQHandler
         8   -- Indirect call
       8   DMA3_IRQHandler
         8   -- Indirect call
       8   DMA4_IRQHandler
         8   -- Indirect call
       8   DMA5_IRQHandler
         8   -- Indirect call
       8   DMA6_IRQHandler
         8   -- Indirect call
       8   DMA7_IRQHandler
         8   -- Indirect call
       8   DMA8_IRQHandler
         8   -- Indirect call
       8   DMA9_IRQHandler
         8   -- Indirect call
      24   LPLD_DMA_DisableIrq
        24   -> __NVIC_DisableIRQ
      24   LPLD_DMA_EnableIrq
        24   -> __NVIC_EnableIRQ
      72   LPLD_DMA_Init
        72   -> assert_failed
      16   LPLD_DMA_SoftwareStartService
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      44  ?_0
      20  DMA0_IRQHandler
      20  DMA10_IRQHandler
      20  DMA11_IRQHandler
      20  DMA12_IRQHandler
      20  DMA13_IRQHandler
      20  DMA14_IRQHandler
      20  DMA15_IRQHandler
      20  DMA1_IRQHandler
      20  DMA2_IRQHandler
      20  DMA3_IRQHandler
      20  DMA4_IRQHandler
      20  DMA5_IRQHandler
      20  DMA6_IRQHandler
      20  DMA7_IRQHandler
      20  DMA8_IRQHandler
      20  DMA9_IRQHandler
      64  DMA_ISR
      22  LPLD_DMA_DisableIrq
      22  LPLD_DMA_EnableIrq
     662  LPLD_DMA_Init
      32  LPLD_DMA_SoftwareStartService
      40  __NVIC_DisableIRQ
      32  __NVIC_EnableIRQ

 
    64 bytes in section .bss
    44 bytes in section .rodata
 1 170 bytes in section .text
 
 1 170 bytes of CODE  memory
    44 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: 1
