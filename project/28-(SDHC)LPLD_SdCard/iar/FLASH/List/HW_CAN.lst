###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         02/Jul/2019  17:59:14
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_CAN.c
#    Command line =  
#        -f C:\Users\admin\AppData\Local\Temp\EW4ACC.tmp
#        (G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_CAN.c -D LPLD_K60 -lCN
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -lB
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List"
#        -o "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        G:\AIcar\arm\inc\c\DLib_Config_Normal.h -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\app\" -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\CPU\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\HW\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\LPLD\DEV\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Ports\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\uCOS-II\Source\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\FatFs\option\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\common\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\driver\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\descriptor\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\USB\class\"
#        -I
#        "G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\..\..\..\lib\Jay\"
#        -On -I G:\AIcar\arm\CMSIS\Core\Include\ -I
#        G:\AIcar\arm\CMSIS\DSP\Include\ -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\List\HW_CAN.lst
#    Object file  =  
#        G:\AIcar\@@\xiugai\project\28-(SDHC)LPLD_SdCard\iar\FLASH\Obj\HW_CAN.o
#
###############################################################################

G:\AIcar\@@\xiugai\lib\LPLD\HW\HW_CAN.c
      1          /**
      2           * @file HW_CAN.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-3-9
      5           * @brief CAN底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....'....        LDR.W    R1,??DataTable19  ;; 0xe000e100
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40E             BMI.N    ??__NVIC_DisableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....'....        LDR.W    R1,??DataTable19_1  ;; 0xe000e180
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x18   0x095B             LSRS     R3,R3,#+5
   \       0x1A   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x26   0x4770             BX       LR               ;; return
     24          #include "HW_CAN.h"
     25          //FlexCAN模块设置波特率函数
     26          static void LPLD_CAN_SetBaudRate(CAN_Type *,uint32 );
     27          //FlexCAN 清楚中断标志位函数
     28          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *, uint8 );
     29          //FlexCAN 获得中断标志位函数
     30          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *, uint8 );
     31          //FlexCAN 解锁Msg缓冲区函数
     32          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *);
     33          //FlexCAN 使能Msg缓冲区中断函数
     34          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *, uint8 );
     35          //FlexCAN 设置Msg缓冲区的CODE
     36          static void LPLD_CAN_SetMsgCode(CAN_Type *, uint8 , uint8 );
     37          //FlexCAN 获得Msg缓冲区的CODE
     38          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *, uint8 );
     39          //FlexCAN 获得Msg缓冲区的TIMESTAMP
     40          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *, uint8 );
     41          //FlexCAN 设置Msg缓冲区的ID
     42          void LPLD_CAN_SetMsgID(CAN_Type *, uint8 ,uint8, uint32 );
     43          //FlexCAN 获得Msg缓冲区的ID
     44          static uint32 LPLD_CAN_GetMsgID(CAN_Type *, uint8 );
     45          //FlexCAN 获得Msg缓冲区的长度
     46          uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 MSG_NUM);
     47          //FlexCAN 获得Msg缓冲区的数据
     48          static void LPLD_CAN_GetData(CAN_Type *canx, uint8 , uint8 ,  uint8 *);
     49          //FlexCAN 写Msg缓冲区的数据
     50          static void LPLD_CAN_WriteData(CAN_Type *, uint8 , uint8, uint8 * );
     51          //FlexCAN 传输中断函数
     52          void LPLD_CAN_Transmit_Interrupt(CAN_Type *, uint8 );
     53          //FlexCAN 接收中断函数
     54          static void LPLD_CAN_Receive_Interrupt(CAN_Type *, uint8 );
     55          //FlexCAN CANx的中断处理函数
     56          static void LPLD_CAN_MB_ISR(void);
     57          //设置16个Msg的结构体

   \                                 In section .bss, align 4
     58          CAN_MSGOBJ_InitTypeDef  flexcan_msgobj_param_t[MSG_MAX_NO] = {0};
   \                     flexcan_msgobj_param_t:
   \        0x0                      DS8 256
     59          //设置CANx Msg的中断回掉函数

   \                                 In section .bss, align 4
     60          CAN_ISR_CALLBACK CAN0_ISR[MSG_MAX_NO];
   \                     CAN0_ISR:
   \        0x0                      DS8 64

   \                                 In section .bss, align 4
     61          CAN_ISR_CALLBACK CAN1_ISR[MSG_MAX_NO];
   \                     CAN1_ISR:
   \        0x0                      DS8 64
     62          
     63          /*
     64           * LPLD_CAN_Init
     65           * 在该函数中使能CANx，设置CANx的波特率，选择相应的工作模式
     66           * 通过CAN_InitTypeDef结构体对CAN进行初始化。
     67           * 
     68           * 参数:
     69           *    CAN_InitTypeDef--can_init_structure
     70           *                     具体定义见HW_CAN.h can_init_structure
     71           *
     72           * 输出:
     73           *    无
     74           *
     75           */

   \                                 In section .text, align 2, keep-with-next
     76          void LPLD_CAN_Init(CAN_InitTypeDef can_init_structure)
     77          {
   \                     LPLD_CAN_Init: (+1)
   \        0x0   0xE92D 0x43F7      PUSH     {R0-R2,R4-R9,LR}
     78            uint8 i;
     79            CAN_Type *canx = can_init_structure.CAN_Canx;
   \        0x4   0x9C00             LDR      R4,[SP, #+0]
     80            uint32 baud = can_init_structure.CAN_BaudRate;
   \        0x6   0x9D01             LDR      R5,[SP, #+4]
     81            uint8  mask_mode = can_init_structure.CAN_RxMaskMode;
   \        0x8   0xF89D 0x6008      LDRB     R6,[SP, #+8]
     82            PortPinsEnum_Type tx_pin = can_init_structure.CAN_TxPin;
   \        0xC   0xF89D 0x7009      LDRB     R7,[SP, #+9]
     83            PortPinsEnum_Type rx_pin = can_init_structure.CAN_RxPin;
   \       0x10   0xF89D 0x800A      LDRB     R8,[SP, #+10]
     84          
     85            ASSERT(mask_mode <= CAN_MSGOBJ_GLOBAL_MASKING);
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xDB04             BLT.N    ??LPLD_CAN_Init_0
   \       0x1C   0x2155             MOVS     R1,#+85
   \       0x1E   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x22   0x....'....        BL       assert_failed
     86            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \                     ??LPLD_CAN_Init_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable19_3  ;; 0xf4241
   \       0x2A   0x4285             CMP      R5,R0
   \       0x2C   0xD304             BCC.N    ??LPLD_CAN_Init_1
   \       0x2E   0x2156             MOVS     R1,#+86
   \       0x30   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x34   0x....'....        BL       assert_failed
     87              
     88            OSC->CR |= OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK;
   \                     ??LPLD_CAN_Init_1: (+1)
   \       0x38   0x....'....        LDR.W    R0,??DataTable19_4  ;; 0x40065000
   \       0x3C   0x7801             LDRB     R1,[R0, #+0]
   \       0x3E   0xF051 0x01A0      ORRS     R1,R1,#0xA0
   \       0x42   0x7001             STRB     R1,[R0, #+0]
     89            
     90            if(canx == CAN0)
   \       0x44   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0xD106             BNE.N    ??LPLD_CAN_Init_2
     91              SIM->SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK;
   \       0x4C   0x....'....        LDR.W    R1,??DataTable19_6  ;; 0x4004803c
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0xF052 0x0210      ORRS     R2,R2,#0x10
   \       0x56   0x600A             STR      R2,[R1, #+0]
   \       0x58   0xE005             B.N      ??LPLD_CAN_Init_3
     92            else
     93              SIM->SCGC3 |= SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Init_2: (+1)
   \       0x5A   0x....'....        LDR.W    R1,??DataTable19_7  ;; 0x40048030
   \       0x5E   0x680A             LDR      R2,[R1, #+0]
   \       0x60   0xF052 0x0210      ORRS     R2,R2,#0x10
   \       0x64   0x600A             STR      R2,[R1, #+0]
     94            
     95            if(canx == CAN0)
   \                     ??LPLD_CAN_Init_3: (+1)
   \       0x66   0x4284             CMP      R4,R0
   \       0x68   0xD11E             BNE.N    ??LPLD_CAN_Init_4
     96            {
     97              if(tx_pin == PTB18)//CAN0_TX
   \       0x6A   0x0038             MOVS     R0,R7
   \       0x6C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6E   0x2832             CMP      R0,#+50
   \       0x70   0xD105             BNE.N    ??LPLD_CAN_Init_5
     98              {
     99                PORTB->PCR[18] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \       0x72   0xF240 0x2003      MOVW     R0,#+515
   \       0x76   0x....'....        LDR.W    R1,??DataTable19_8  ;; 0x4004a048
   \       0x7A   0x6008             STR      R0,[R1, #+0]
   \       0x7C   0xE004             B.N      ??LPLD_CAN_Init_6
    100              }
    101              else
    102              {
    103                PORTA->PCR[12] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_5: (+1)
   \       0x7E   0xF44F 0x7000      MOV      R0,#+512
   \       0x82   0x....'....        LDR.W    R1,??DataTable19_9  ;; 0x40049030
   \       0x86   0x6008             STR      R0,[R1, #+0]
    104              }
    105          
    106              if(rx_pin == PTB19)//CAN0_RX
   \                     ??LPLD_CAN_Init_6: (+1)
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x8C   0x2833             CMP      R0,#+51
   \       0x8E   0xD105             BNE.N    ??LPLD_CAN_Init_7
    107              {
    108                PORTB->PCR[19] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \       0x90   0xF240 0x2003      MOVW     R0,#+515
   \       0x94   0x....'....        LDR.W    R1,??DataTable19_10  ;; 0x4004a04c
   \       0x98   0x6008             STR      R0,[R1, #+0]
   \       0x9A   0xE023             B.N      ??LPLD_CAN_Init_8
    109              }
    110              else
    111              {
    112                PORTA->PCR[13] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_7: (+1)
   \       0x9C   0xF44F 0x7000      MOV      R0,#+512
   \       0xA0   0x....'....        LDR.W    R1,??DataTable19_11  ;; 0x40049034
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   \       0xA6   0xE01D             B.N      ??LPLD_CAN_Init_8
    113              }
    114            }
    115            else
    116            {
    117              if(tx_pin == PTC17)//CAN1_TX
   \                     ??LPLD_CAN_Init_4: (+1)
   \       0xA8   0x0038             MOVS     R0,R7
   \       0xAA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xAC   0x284D             CMP      R0,#+77
   \       0xAE   0xD105             BNE.N    ??LPLD_CAN_Init_9
    118              {
    119                PORTC->PCR[17] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \       0xB0   0xF240 0x2003      MOVW     R0,#+515
   \       0xB4   0x....'....        LDR.W    R1,??DataTable19_12  ;; 0x4004b044
   \       0xB8   0x6008             STR      R0,[R1, #+0]
   \       0xBA   0xE004             B.N      ??LPLD_CAN_Init_10
    120              }
    121              else
    122              {
    123                PORTE->PCR[24] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_9: (+1)
   \       0xBC   0xF240 0x2003      MOVW     R0,#+515
   \       0xC0   0x....'....        LDR.W    R1,??DataTable19_13  ;; 0x4004d060
   \       0xC4   0x6008             STR      R0,[R1, #+0]
    124              }
    125          
    126              if(rx_pin == PTC16)//CAN1_RX
   \                     ??LPLD_CAN_Init_10: (+1)
   \       0xC6   0x4640             MOV      R0,R8
   \       0xC8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xCA   0x284C             CMP      R0,#+76
   \       0xCC   0xD105             BNE.N    ??LPLD_CAN_Init_11
    127              {
    128                PORTC->PCR[16] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \       0xCE   0xF240 0x2003      MOVW     R0,#+515
   \       0xD2   0x....'....        LDR.W    R1,??DataTable19_14  ;; 0x4004b040
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   \       0xD8   0xE004             B.N      ??LPLD_CAN_Init_8
    129              }
    130              else
    131              {
    132                PORTE->PCR[25] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_11: (+1)
   \       0xDA   0xF240 0x2003      MOVW     R0,#+515
   \       0xDE   0x....'....        LDR.W    R1,??DataTable19_15  ;; 0x4004d064
   \       0xE2   0x6008             STR      R0,[R1, #+0]
    133              }
    134            } 
    135            //禁止CAN外设
    136            canx->MCR   |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Init_8: (+1)
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \       0xEA   0x6020             STR      R0,[R4, #+0]
    137            //只有在LPM_ACK = 1情况下才可以选择钟源
    138            canx->CTRL1 |= CAN_CTRL1_CLKSRC_MASK;  //选择peripheral clock作为CAN外设的时钟源
   \       0xEC   0x6860             LDR      R0,[R4, #+4]
   \       0xEE   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0xF2   0x6060             STR      R0,[R4, #+4]
    139                                                   //设置此位必须在CAN停止模式下
    140            //在时钟初始化完毕和CAN总线使能完毕后，
    141            //单片机自动进入冻结模式
    142            //只有在冻结模式下才能配置大多数CAN总线寄存器
    143            //使能冻结模式 
    144            canx->MCR |= CAN_MCR_FRZ_MASK;
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0xFA   0x6020             STR      R0,[R4, #+0]
    145            canx->MCR &= ~CAN_MCR_MDIS_MASK; 
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x102   0x6020             STR      R0,[R4, #+0]
    146            
    147            while(!(canx->MCR & CAN_MCR_LPMACK_MASK));	
   \                     ??LPLD_CAN_Init_12: (+1)
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x02C0             LSLS     R0,R0,#+11
   \      0x108   0xD5FC             BPL.N    ??LPLD_CAN_Init_12
    148          
    149            //进行软件复位
    150            canx->MCR ^= CAN_MCR_SOFTRST_MASK;
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0xF090 0x7000      EORS     R0,R0,#0x2000000
   \      0x110   0x6020             STR      R0,[R4, #+0]
    151            while(canx->MCR & CAN_MCR_SOFTRST_MASK);
   \                     ??LPLD_CAN_Init_13: (+1)
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0x0180             LSLS     R0,R0,#+6
   \      0x116   0xD4FC             BMI.N    ??LPLD_CAN_Init_13
    152                      
    153            //等待进入冻结模式 
    154            while(!(canx->MCR & CAN_MCR_FRZACK_MASK));
   \                     ??LPLD_CAN_Init_14: (+1)
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x01C0             LSLS     R0,R0,#+7
   \      0x11C   0xD5FC             BPL.N    ??LPLD_CAN_Init_14
    155            
    156            if(mask_mode == CAN_MSGOBJ_GLOBAL_MASKING)
   \      0x11E   0x0030             MOVS     R0,R6
   \      0x120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x122   0x2801             CMP      R0,#+1
   \      0x124   0xD104             BNE.N    ??LPLD_CAN_Init_15
    157            {
    158              canx->MCR &= ~CAN_MCR_IRMQ_MASK;   //使能全局匹配寄存器禁止单独匹配 
   \      0x126   0x6820             LDR      R0,[R4, #+0]
   \      0x128   0xF430 0x3080      BICS     R0,R0,#0x10000
   \      0x12C   0x6020             STR      R0,[R4, #+0]
   \      0x12E   0xE003             B.N      ??LPLD_CAN_Init_16
    159            }
    160            else
    161            {
    162              canx->MCR |= CAN_MCR_IRMQ_MASK;   //使能Msg单独匹配 
   \                     ??LPLD_CAN_Init_15: (+1)
   \      0x130   0x6820             LDR      R0,[R4, #+0]
   \      0x132   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \      0x136   0x6020             STR      R0,[R4, #+0]
    163            }
    164            //将MB_MAX个邮箱缓冲区内容清0
    165            for(i = 0;i < MSG_MAX_NO; i++)
   \                     ??LPLD_CAN_Init_16: (+1)
   \      0x138   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??LPLD_CAN_Init_17: (+1)
   \      0x13C   0x4648             MOV      R0,R9
   \      0x13E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x140   0x2810             CMP      R0,#+16
   \      0x142   0xDA1E             BGE.N    ??LPLD_CAN_Init_18
    166            {
    167              canx->MB[i].CS    = 0x00000000;
   \      0x144   0x2000             MOVS     R0,#+0
   \      0x146   0x4649             MOV      R1,R9
   \      0x148   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x14A   0x0109             LSLS     R1,R1,#+4
   \      0x14C   0x4421             ADD      R1,R4,R1
   \      0x14E   0xF8C1 0x0080      STR      R0,[R1, #+128]
    168              canx->MB[i].ID    = 0x00000000;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x4649             MOV      R1,R9
   \      0x156   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x158   0x0109             LSLS     R1,R1,#+4
   \      0x15A   0x4421             ADD      R1,R4,R1
   \      0x15C   0xF8C1 0x0084      STR      R0,[R1, #+132]
    169              canx->MB[i].WORD0 = 0x00000000;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x4649             MOV      R1,R9
   \      0x164   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x166   0x0109             LSLS     R1,R1,#+4
   \      0x168   0x4421             ADD      R1,R4,R1
   \      0x16A   0xF8C1 0x0088      STR      R0,[R1, #+136]
    170              canx->MB[i].WORD1 = 0x00000000;        
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x4649             MOV      R1,R9
   \      0x172   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x174   0x0109             LSLS     R1,R1,#+4
   \      0x176   0x4421             ADD      R1,R4,R1
   \      0x178   0xF8C1 0x008C      STR      R0,[R1, #+140]
    171            }
   \      0x17C   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x180   0xE7DC             B.N      ??LPLD_CAN_Init_17
    172            
    173            canx->MCR |= CAN_MCR_SRXDIS_MASK ; //禁止自我接收
   \                     ??LPLD_CAN_Init_18: (+1)
   \      0x182   0x6820             LDR      R0,[R4, #+0]
   \      0x184   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \      0x188   0x6020             STR      R0,[R4, #+0]
    174            //canx->MCR |= CAN_MCR_RFEN_MASK ;   //使能接收FIFO
    175            //canx->CTRL2 |= CAN_CTRL2_RFFN(0);
    176            //canx->MCR |= CAN_MCR_IDAM(0);
    177            
    178            //配置相关的寄存器
    179            canx->CTRL2 &= ~CAN_CTRL2_EACEN_MASK; //接收邮箱过滤IDE匹配，RTR不匹配
   \      0x18A   0x6B60             LDR      R0,[R4, #+52]
   \      0x18C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \      0x190   0x6360             STR      R0,[R4, #+52]
    180            canx->CTRL2 &= ~CAN_CTRL2_RRS_MASK;  //不自动产生远程请求帧产生
   \      0x192   0x6B60             LDR      R0,[R4, #+52]
   \      0x194   0xF430 0x3000      BICS     R0,R0,#0x20000
   \      0x198   0x6360             STR      R0,[R4, #+52]
    181            canx->CTRL2 &= ~CAN_CTRL2_MRP_MASK;   //ID首先从邮箱中匹配
   \      0x19A   0x6B60             LDR      R0,[R4, #+52]
   \      0x19C   0xF430 0x2080      BICS     R0,R0,#0x40000
   \      0x1A0   0x6360             STR      R0,[R4, #+52]
    182          
    183            //canx->CTRL1 |= CAN_CTRL1_LBUF_MASK;  //发送的时候从低Msg开始
    184            canx->CTRL1 &= ~CAN_CTRL1_LBUF_MASK;   //发送的时候从低优先级发送
   \      0x1A2   0x6860             LDR      R0,[R4, #+4]
   \      0x1A4   0xF030 0x0010      BICS     R0,R0,#0x10
   \      0x1A8   0x6060             STR      R0,[R4, #+4]
    185                                       
    186            //canx->CTRL1 |= CAN_CTRL1_LPB_MASK;  //loop 模式,用于测试
    187            canx->CTRL1 &= ~CAN_CTRL1_LPB_MASK;   //使用正常模式
   \      0x1AA   0x6860             LDR      R0,[R4, #+4]
   \      0x1AC   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x1B0   0x6060             STR      R0,[R4, #+4]
    188            //设置CAN总线通信的波特率
    189            LPLD_CAN_SetBaudRate(canx,baud);
   \      0x1B2   0x0029             MOVS     R1,R5
   \      0x1B4   0x0020             MOVS     R0,R4
   \      0x1B6   0x....'....        BL       LPLD_CAN_SetBaudRate
    190          
    191            //清空CAN自由计数器 
    192            canx->TIMER = 0x0000; 
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0x60A0             STR      R0,[R4, #+8]
    193             /*
    194            如果MCR的IRMQ为1，表示每个邮箱都可以单独进行ID匹配
    195            注意：如果是low cost MCUs（低配置的MCU），没有单独匹配这项功能。
    196                    1\ID匹配会选择free to receive状态的邮箱作为胜者，
    197                    获胜的邮箱可以从接收缓冲区内将接收的帧 Move in 到MB中；
    198                    2\如果出现ID号相同的邮箱，会首先从序号低的邮箱进行匹配，如果
    199                    低序号邮箱是non free to receive状态，那么匹配过程将会查找
    200                    下一个邮箱直到找到free to receive状态且ID相同的邮箱；
    201                    3\如果ID号相同的邮箱都处于non free to receive状态，那么匹配过程
    202                    将停止在最后一个有相同ID的邮箱位置，将帧Move in 到MB中并且将该邮
    203                    箱的状态设置成OVERRUN。
    204                    RXIMR[i]存储在单片机的RAM中，只有在CAN冻结模式下可写。
    205                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK不起作用
    206            */
    207            if(canx->MCR & CAN_MCR_IRMQ_MASK)
   \      0x1BE   0x6820             LDR      R0,[R4, #+0]
   \      0x1C0   0x03C0             LSLS     R0,R0,#+15
   \      0x1C2   0xD510             BPL.N    ??LPLD_CAN_Init_19
    208            {
    209              for(i = 0;i < MSG_MAX_NO; i++)
   \      0x1C4   0x2000             MOVS     R0,#+0
   \      0x1C6   0x4681             MOV      R9,R0
   \                     ??LPLD_CAN_Init_20: (+1)
   \      0x1C8   0x4648             MOV      R0,R9
   \      0x1CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1CC   0x2810             CMP      R0,#+16
   \      0x1CE   0xDA0A             BGE.N    ??LPLD_CAN_Init_19
    210              {
    211                canx->RXIMR[i] = 0x1FFFFFFFL;//设置邮箱29位全部屏蔽
   \      0x1D0   0xF07F 0x4060      MVNS     R0,#-536870912
   \      0x1D4   0x4649             MOV      R1,R9
   \      0x1D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x1D8   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \      0x1DC   0xF8C1 0x0880      STR      R0,[R1, #+2176]
    212              }
   \      0x1E0   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x1E4   0xE7F0             B.N      ??LPLD_CAN_Init_20
    213            } 
    214           /*
    215            如果MCR的IRMQ为0，表示使用全局匹配寄存器进行匹配，
    216                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK起作用；
    217                    CANx_RXMGMASK管理除CANx_RX14MASK、CANx_RX15MASK以外的所有Msg；
    218                    ID匹配过程会停止在找到的第一个ID相同的邮箱位置，不管该邮箱是否处于
    219                    free to receive状态。
    220            */
    221          
    222            canx->RXMGMASK = 0x1FFFFFFF; //29位ID全部匹配            
   \                     ??LPLD_CAN_Init_19: (+1)
   \      0x1E6   0xF07F 0x4060      MVNS     R0,#-536870912
   \      0x1EA   0x6120             STR      R0,[R4, #+16]
    223            canx->RX14MASK = 0x1FFFFFFF;
   \      0x1EC   0x6160             STR      R0,[R4, #+20]
    224            canx->RX15MASK = 0x1FFFFFFF; 
   \      0x1EE   0x61A0             STR      R0,[R4, #+24]
    225           
    226            canx->MCR &= ~(CAN_MCR_HALT_MASK); 
   \      0x1F0   0x6820             LDR      R0,[R4, #+0]
   \      0x1F2   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \      0x1F6   0x6020             STR      R0,[R4, #+0]
    227            //等到不在冻结模式，休眠模式或者停止模式
    228            while( canx->MCR & CAN_MCR_FRZACK_MASK); 
   \                     ??LPLD_CAN_Init_21: (+1)
   \      0x1F8   0x6820             LDR      R0,[R4, #+0]
   \      0x1FA   0x01C0             LSLS     R0,R0,#+7
   \      0x1FC   0xD4FC             BMI.N    ??LPLD_CAN_Init_21
    229            
    230            while( canx->MCR & CAN_MCR_NOTRDY_MASK);
   \                     ??LPLD_CAN_Init_22: (+1)
   \      0x1FE   0x6820             LDR      R0,[R4, #+0]
   \      0x200   0x0100             LSLS     R0,R0,#+4
   \      0x202   0xD4FC             BMI.N    ??LPLD_CAN_Init_22
    231          }
   \      0x204   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    232          /*
    233           * LPLD_CAN_SetBaudRate
    234           * 设置CAN波特率,PLL必须是100Mhz
    235           * 参数:
    236           *    CAN_Type *canx
    237           *      |___CAN0 --CAN0号模块
    238           *      |___CAN1 --CAN0号模块
    239           *    baud 波特率
    240           *      |__CAN_BAUD_RATE_50KBPS  --波特率50KBPS
    241           *      |__CAN_BAUD_RATE_100KBPS --波特率100KBPS
    242           *      |__CAN_BAUD_RATE_250KBPS --波特率250KBPS
    243           *      |__CAN_BAUD_RATE_500KBPS --波特率500KBPS
    244           *      |__CAN_BAUD_RATE_1MBPS   --波特率1MBPS
    245           *  输出：
    246           *    无
    247          */

   \                                 In section .text, align 2, keep-with-next
    248          static void LPLD_CAN_SetBaudRate(CAN_Type *canx,uint32 baud)
    249          {
   \                     LPLD_CAN_SetBaudRate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    250            uint8 prescale;
    251            //1个CAN总线位的时间量子：Time Quanta = SYNC_SEG + (PROP_SEG + PSEG1 + 2) + (PSEG2 + 1)，
    252            //SYNC_SEG =  1 （固定值）
    253            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \        0x6   0x....'....        LDR.W    R0,??DataTable19_3  ;; 0xf4241
   \        0xA   0x4285             CMP      R5,R0
   \        0xC   0xD304             BCC.N    ??LPLD_CAN_SetBaudRate_0
   \        0xE   0x21FD             MOVS     R1,#+253
   \       0x10   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x14   0x....'....        BL       assert_failed
    254            switch(baud)
   \                     ??LPLD_CAN_SetBaudRate_0: (+1)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xF248 0x2135      MOVW     R1,#+33333
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD02B             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \       0x22   0xF24C 0x3150      MOVW     R1,#+50000
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD039             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \       0x2A   0x....'....        LDR.W    R1,??DataTable19_16  ;; 0x14585
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD023             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \       0x32   0x....'....        LDR.W    R1,??DataTable19_17  ;; 0x186a0
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD01F             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \       0x3A   0x....'....        LDR.W    R1,??DataTable19_18  ;; 0x1e848
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD01B             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \       0x42   0x....'....        LDR.W    R1,??DataTable19_19  ;; 0x3d090
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD029             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \       0x4A   0x....'....        LDR.W    R1,??DataTable19_20  ;; 0x7a120
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD025             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \       0x52   0x....'....        LDR.W    R1,??DataTable19_21  ;; 0xf4240
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD133             BNE.N    ??LPLD_CAN_SetBaudRate_3
    255            {
    256              case CAN_BAUD_RATE_1MBPS:
    257                {
    258                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,8); 
   \                     ??LPLD_CAN_SetBaudRate_4: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable19_22
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x00E9             LSLS     R1,R5,#+3
   \       0x62   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x66   0x1E40             SUBS     R0,R0,#+1
   \       0x68   0x0006             MOVS     R6,R0
    259                  //设置CAN总线通信的波特率
    260                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(3)
    261                                   | CAN_CTRL1_RJW(0)   
    262                                   | CAN_CTRL1_PSEG1(0) 
    263                                   | CAN_CTRL1_PSEG2(1)
    264                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \       0x6A   0x0030             MOVS     R0,R6
   \       0x6C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6E   0x....'....        LDR.W    R1,??DataTable19_23  ;; 0x10003
   \       0x72   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \       0x76   0x6061             STR      R1,[R4, #+4]
    265                  break;
   \       0x78   0xE023             B.N      ??LPLD_CAN_SetBaudRate_5
    266                }
    267              case CAN_BAUD_RATE_33KBPS:
    268              case CAN_BAUD_RATE_83KBPS:
    269              case CAN_BAUD_RATE_100KBPS:
    270              case CAN_BAUD_RATE_125KBPS:
    271                {
    272                  //设置time_quanta = 12 
    273                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,12); 
   \                     ??LPLD_CAN_SetBaudRate_1: (+1)
   \       0x7A   0x....'....        LDR.W    R0,??DataTable19_22
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x210C             MOVS     R1,#+12
   \       0x82   0xFB01 0xF105      MUL      R1,R1,R5
   \       0x86   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
   \       0x8C   0x0006             MOVS     R6,R0
    274                  //设置CAN总线通信的波特率
    275                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(2) 
    276                                   | CAN_CTRL1_RJW(2)  
    277                                   | CAN_CTRL1_PSEG1(3) 
    278                                   | CAN_CTRL1_PSEG2(3)
    279                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \       0x8E   0x0030             MOVS     R0,R6
   \       0x90   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x92   0x....'....        LDR.W    R1,??DataTable19_24  ;; 0x9b0002
   \       0x96   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \       0x9A   0x6061             STR      R1,[R4, #+4]
    280                  break;
   \       0x9C   0xE011             B.N      ??LPLD_CAN_SetBaudRate_5
    281                }
    282              case CAN_BAUD_RATE_50KBPS:
    283              case CAN_BAUD_RATE_500KBPS:
    284              case CAN_BAUD_RATE_250KBPS:
    285                {
    286                  //设置time_quanta = 12 
    287                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,12); 
   \                     ??LPLD_CAN_SetBaudRate_2: (+1)
   \       0x9E   0x....'....        LDR.W    R0,??DataTable19_22
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0x210C             MOVS     R1,#+12
   \       0xA6   0xFB01 0xF105      MUL      R1,R1,R5
   \       0xAA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0xAE   0x1E40             SUBS     R0,R0,#+1
   \       0xB0   0x0006             MOVS     R6,R0
    288                  //设置CAN总线通信的波特率
    289                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(2)
    290                                   | CAN_CTRL1_RJW(1)  
    291                                   | CAN_CTRL1_PSEG1(3) 
    292                                   | CAN_CTRL1_PSEG2(3)
    293                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \       0xB2   0x0030             MOVS     R0,R6
   \       0xB4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xB6   0x....'....        LDR.W    R1,??DataTable19_25  ;; 0x5b0002
   \       0xBA   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \       0xBE   0x6061             STR      R1,[R4, #+4]
    294                  break;
   \       0xC0   0xE7FF             B.N      ??LPLD_CAN_SetBaudRate_5
    295                }
    296              default:break;
    297            }
    298          }
   \                     ??LPLD_CAN_SetBaudRate_3: (+1)
   \                     ??LPLD_CAN_SetBaudRate_5: (+1)
   \       0xC2   0xBD70             POP      {R4-R6,PC}       ;; return
    299          
    300          /*
    301           * LPLD_CAN_Deinit
    302           * CAN反初始化函数，在该函数中禁止CANx的总线时钟，禁止模块中断，关闭CAN模块
    303           * 
    304           * 参数:
    305           *    CAN_InitTypeDef--can_init_structure
    306           *                     具体定义见HW_CAN.h can_init_structure
    307           * 输出:
    308           *    无
    309           *
    310          */

   \                                 In section .text, align 2, keep-with-next
    311          void LPLD_CAN_Deinit(CAN_InitTypeDef can_init_structure)
    312          {
   \                     LPLD_CAN_Deinit: (+1)
   \        0x0   0xB517             PUSH     {R0-R2,R4,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
    313            CAN_Type *canx = can_init_structure.CAN_Canx;
   \        0x4   0x9C01             LDR      R4,[SP, #+4]
    314            
    315            if(canx == CAN0)
   \        0x6   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD109             BNE.N    ??LPLD_CAN_Deinit_0
    316            {
    317              SIM->SCGC6 &= ~SIM_SCGC6_FLEXCAN0_MASK;
   \        0xE   0x....'....        LDR.W    R0,??DataTable19_6  ;; 0x4004803c
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x18   0x6001             STR      R1,[R0, #+0]
    318              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \       0x1A   0x201D             MOVS     R0,#+29
   \       0x1C   0x....'....        BL       __NVIC_DisableIRQ
   \       0x20   0xE008             B.N      ??LPLD_CAN_Deinit_1
    319            }
    320            else
    321            {
    322              SIM->SCGC3 &= ~SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Deinit_0: (+1)
   \       0x22   0x....'....        LDR.W    R0,??DataTable19_7  ;; 0x40048030
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x2C   0x6001             STR      R1,[R0, #+0]
    323              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \       0x2E   0x2025             MOVS     R0,#+37
   \       0x30   0x....'....        BL       __NVIC_EnableIRQ
    324            }
    325            //禁止CAN外设
    326            canx->MCR |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Deinit_1: (+1)
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \       0x3A   0x6020             STR      R0,[R4, #+0]
    327            canx->MCR |= CAN_MCR_HALT_MASK; 
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0x42   0x6020             STR      R0,[R4, #+0]
    328            canx->MCR |= CAN_MCR_FRZ_MASK;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0x4A   0x6020             STR      R0,[R4, #+0]
    329          }
   \       0x4C   0xBD1F             POP      {R0-R4,PC}       ;; return
    330          /*
    331           * LPLD_CAN_EnableIrq
    332           * 使能CAN模块中断
    333           * 
    334           * 参数:
    335           *    CAN_InitTypeDef--can_init_structure
    336           *                     具体定义见HW_CAN.h can_init_structure
    337           * 输出:
    338           *    无
    339           *
    340          */

   \                                 In section .text, align 2, keep-with-next
    341          void LPLD_CAN_EnableIrq(CAN_InitTypeDef can_init_structure)
    342          {
   \                     LPLD_CAN_EnableIrq: (+1)
   \        0x0   0xB517             PUSH     {R0-R2,R4,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
    343            CAN_Type *canx = can_init_structure.CAN_Canx;
   \        0x4   0x9C01             LDR      R4,[SP, #+4]
    344              
    345            if(canx == CAN0)
   \        0x6   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD103             BNE.N    ??LPLD_CAN_EnableIrq_0
    346            {
    347              enable_irq(CAN0_ORed_Message_buffer_IRQn);
   \        0xE   0x201D             MOVS     R0,#+29
   \       0x10   0x....'....        BL       __NVIC_EnableIRQ
   \       0x14   0xE006             B.N      ??LPLD_CAN_EnableIrq_1
    348            }
    349            else if(canx == CAN1)
   \                     ??LPLD_CAN_EnableIrq_0: (+1)
   \       0x16   0x....'....        LDR.W    R0,??DataTable19_26  ;; 0x400a4000
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??LPLD_CAN_EnableIrq_1
    350            {
    351              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \       0x1E   0x2025             MOVS     R0,#+37
   \       0x20   0x....'....        BL       __NVIC_EnableIRQ
    352            }
    353          }
   \                     ??LPLD_CAN_EnableIrq_1: (+1)
   \       0x24   0xBD1F             POP      {R0-R4,PC}       ;; return
    354          
    355          /*
    356           * LPLD_CAN_DisableIrq
    357           * 禁止CAN模块中断
    358           * 
    359           * 参数:
    360           *    CAN_InitTypeDef--can_init_structure
    361           *                     具体定义见HW_CAN.h can_init_structure
    362           * 输出:
    363           *    无
    364           *
    365          */

   \                                 In section .text, align 2, keep-with-next
    366          void LPLD_CAN_DisableIrq(CAN_InitTypeDef can_init_structure)
    367          {
   \                     LPLD_CAN_DisableIrq: (+1)
   \        0x0   0xB517             PUSH     {R0-R2,R4,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
    368            CAN_Type *canx = can_init_structure.CAN_Canx;
   \        0x4   0x9C01             LDR      R4,[SP, #+4]
    369              
    370            if(canx == CAN0)
   \        0x6   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD103             BNE.N    ??LPLD_CAN_DisableIrq_0
    371            {
    372              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \        0xE   0x201D             MOVS     R0,#+29
   \       0x10   0x....'....        BL       __NVIC_DisableIRQ
   \       0x14   0xE006             B.N      ??LPLD_CAN_DisableIrq_1
    373            }
    374            else if(canx == CAN1)
   \                     ??LPLD_CAN_DisableIrq_0: (+1)
   \       0x16   0x....'....        LDR.W    R0,??DataTable19_26  ;; 0x400a4000
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??LPLD_CAN_DisableIrq_1
    375            {
    376              disable_irq(CAN1_ORed_Message_buffer_IRQn);
   \       0x1E   0x2025             MOVS     R0,#+37
   \       0x20   0x....'....        BL       __NVIC_DisableIRQ
    377            }
    378          }
   \                     ??LPLD_CAN_DisableIrq_1: (+1)
   \       0x24   0xBD1F             POP      {R0-R4,PC}       ;; return
    379          
    380          /*
    381           * LPLD_CAN_InitMessageObject
    382           *
    383           * 设置CAN Message buffer（Msg）格式，通过CAN_MSGOBJ_InitTypeDef
    384           * 结构体对CAN Message buffer进行初始化。
    385           * 
    386           * 参数:
    387           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    388           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    389           *    message_id
    390           *      设置message_id，id长度根据CAN_MSGOBJ_InitTypeDef的参数而定
    391           *      id的长度分为11位标准帧和29位扩展帧两种
    392           *      CAN_MSGOBJ_ID_STD 表示标准帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_STD
    393           *      此时message_id最长为11位，不能超过0x0FFF；
    394           *      CAN_MSGOBJ_ID_EXT 表示扩展帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_EXT
    395           *      此时message_id最长为29位，不能超过0x1FFFFFFF；
    396           * 输出:
    397           *    无
    398           *
    399           */

   \                                 In section .text, align 2, keep-with-next
    400          void LPLD_CAN_InitMessageObject(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,uint32 rx_id)
    401          { 
   \                     LPLD_CAN_InitMessageObject: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0x9E0E             LDR      R6,[SP, #+56]
    402            uint8     msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \        0x8   0xF89D 0x7008      LDRB     R7,[SP, #+8]
    403            uint8     dir           = can_msg_init_structure.CAN_MsgDirection;
   \        0xC   0xF89D 0xB00C      LDRB     R11,[SP, #+12]
    404            CAN_Type *canx_ptr      = can_msg_init_structure.CAN_Canx;
   \       0x10   0xF8DD 0x8004      LDR      R8,[SP, #+4]
    405            uint32    id_type       = can_msg_init_structure.CAN_MsgIdLength;
   \       0x14   0xF89D 0x4009      LDRB     R4,[SP, #+9]
    406            uint32    cs_temp = CAN_MB_CS_CODE(CAN_MSGOBJ_RX_EMPTY);
   \       0x18   0xF05F 0x6980      MOVS     R9,#+67108864
    407            CAN_ISR_CALLBACK isr_func = can_msg_init_structure.CAN_Isr;
   \       0x1C   0xF8DD 0xA010      LDR      R10,[SP, #+16]
    408            uint32    id_temp;	
    409            
    410            if(dir == CAN_MSGOBJ_DIR_RX)
   \       0x20   0x4658             MOV      R0,R11
   \       0x22   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD122             BNE.N    ??LPLD_CAN_InitMessageObject_0
    411            {
    412              canx_ptr->MB[msg_num_temp].CS = CAN_MB_CS_CODE(CAN_MSGOBJ_RX_INACTIVE); 
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x0039             MOVS     R1,R7
   \       0x2C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x2E   0x0109             LSLS     R1,R1,#+4
   \       0x30   0x4441             ADD      R1,R8,R1
   \       0x32   0xF8C1 0x0080      STR      R0,[R1, #+128]
    413              //设置Msg的ID
    414              if(id_type == CAN_MSGOBJ_ID_STD)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD105             BNE.N    ??LPLD_CAN_InitMessageObject_1
    415              {
    416                id_temp =  CAN_MB_ID_STD(rx_id);
   \       0x3A   0x....'....        LDR.W    R0,??DataTable19_27  ;; 0x1ffc0000
   \       0x3E   0xEA10 0x4086      ANDS     R0,R0,R6, LSL #+18
   \       0x42   0x0005             MOVS     R5,R0
   \       0x44   0xE002             B.N      ??LPLD_CAN_InitMessageObject_2
    417              }
    418              else
    419              {
    420                id_temp =  CAN_MB_ID_EXT(rx_id);
   \                     ??LPLD_CAN_InitMessageObject_1: (+1)
   \       0x46   0xF026 0x4060      BIC      R0,R6,#0xE0000000
   \       0x4A   0x0005             MOVS     R5,R0
    421              }
    422              canx_ptr->MB[msg_num_temp].ID = id_temp;  
   \                     ??LPLD_CAN_InitMessageObject_2: (+1)
   \       0x4C   0x0038             MOVS     R0,R7
   \       0x4E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x50   0x0100             LSLS     R0,R0,#+4
   \       0x52   0x4440             ADD      R0,R8,R0
   \       0x54   0xF8C0 0x5084      STR      R5,[R0, #+132]
    423              canx_ptr->MB[msg_num_temp].CS = cs_temp | CAN_MB_CS_IDE(id_type);
   \       0x58   0x0560             LSLS     R0,R4,#+21
   \       0x5A   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \       0x5E   0xEA50 0x0009      ORRS     R0,R0,R9
   \       0x62   0x0039             MOVS     R1,R7
   \       0x64   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x66   0x0109             LSLS     R1,R1,#+4
   \       0x68   0x4441             ADD      R1,R8,R1
   \       0x6A   0xF8C1 0x0080      STR      R0,[R1, #+128]
    424            }
    425            if(can_msg_init_structure.CAN_MsgInterrupt == TRUE)
   \                     ??LPLD_CAN_InitMessageObject_0: (+1)
   \       0x6E   0xF89D 0x000D      LDRB     R0,[SP, #+13]
   \       0x72   0x2801             CMP      R0,#+1
   \       0x74   0xD11C             BNE.N    ??LPLD_CAN_InitMessageObject_3
    426            {
    427              LPLD_CAN_EnableMsgInterrupt(canx_ptr,msg_num_temp);//使能Msg中断 
   \       0x76   0x0039             MOVS     R1,R7
   \       0x78   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x7A   0x4640             MOV      R0,R8
   \       0x7C   0x....'....        BL       LPLD_CAN_EnableMsgInterrupt
    428              //设置Msg中断回掉函数
    429              if(canx_ptr == CAN0)
   \       0x80   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \       0x84   0x4580             CMP      R8,R0
   \       0x86   0xD109             BNE.N    ??LPLD_CAN_InitMessageObject_4
    430              {
    431                if(isr_func != NULL)
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD023             BEQ.N    ??LPLD_CAN_InitMessageObject_5
    432                {
    433                  CAN0_ISR[msg_num_temp] = isr_func;
   \       0x8E   0x....'....        LDR.W    R0,??DataTable19_28
   \       0x92   0x0039             MOVS     R1,R7
   \       0x94   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x96   0xF840 0xA021      STR      R10,[R0, R1, LSL #+2]
   \       0x9A   0xE01C             B.N      ??LPLD_CAN_InitMessageObject_5
    434                }
    435              }
    436              else
    437              {
    438                if(isr_func != NULL)
   \                     ??LPLD_CAN_InitMessageObject_4: (+1)
   \       0x9C   0x4650             MOV      R0,R10
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD019             BEQ.N    ??LPLD_CAN_InitMessageObject_5
    439                {
    440                  CAN1_ISR[msg_num_temp] = isr_func;
   \       0xA2   0x....'....        LDR.W    R0,??DataTable19_29
   \       0xA6   0x0039             MOVS     R1,R7
   \       0xA8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xAA   0xF840 0xA021      STR      R10,[R0, R1, LSL #+2]
   \       0xAE   0xE012             B.N      ??LPLD_CAN_InitMessageObject_5
    441                }
    442              }
    443            }
    444            else
    445            {
    446              if(canx_ptr == CAN0)
   \                     ??LPLD_CAN_InitMessageObject_3: (+1)
   \       0xB0   0x....'....        LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \       0xB4   0x4580             CMP      R8,R0
   \       0xB6   0xD107             BNE.N    ??LPLD_CAN_InitMessageObject_6
    447              {
    448                  CAN0_ISR[msg_num_temp] = NULL; 
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x....'....        LDR.W    R1,??DataTable19_28
   \       0xBE   0x003A             MOVS     R2,R7
   \       0xC0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xC2   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \       0xC6   0xE006             B.N      ??LPLD_CAN_InitMessageObject_5
    449              }
    450              else
    451              {
    452                  CAN1_ISR[msg_num_temp] = NULL;
   \                     ??LPLD_CAN_InitMessageObject_6: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x....'....        LDR.W    R1,??DataTable19_29
   \       0xCE   0x003A             MOVS     R2,R7
   \       0xD0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xD2   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    453              }
    454            }
    455          }
   \                     ??LPLD_CAN_InitMessageObject_5: (+1)
   \       0xD6   0xB005             ADD      SP,SP,#+20
   \       0xD8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    456          /*
    457           * LPLD_CAN_TransmitMessage
    458           * CAN 发送消息函数
    459           * 参数:
    460           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    461           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    462           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    463           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    464           *    该结构体用于定义CAN的消息格式，当CAN发送消息时，会从CAN_MessageFormat_TypeDef定义的结构体对象中
    465           *    提取信息并存储到MSG中，MSG会将消息发送到CAN总线上。
    466           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    467           * 输出:
    468           *    1 发送完毕
    469           *    0 发送失败
    470           *
    471           */

   \                                 In section .text, align 2, keep-with-next
    472          uint8 LPLD_CAN_TransmitMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,
    473                                         CAN_MessageFormat_TypeDef *can_tx_msg )
    474          {
   \                     LPLD_CAN_TransmitMessage: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x9C10             LDR      R4,[SP, #+64]
    475            uint8  request;
    476            uint8  msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \        0x8   0xF89D 0x5010      LDRB     R5,[SP, #+16]
    477            CAN_Type *canx_ptr   = can_msg_init_structure.CAN_Canx;
   \        0xC   0x9E03             LDR      R6,[SP, #+12]
    478            uint32  id_type      = can_msg_init_structure.CAN_MsgIdLength;
   \        0xE   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \       0x12   0x9001             STR      R0,[SP, #+4]
    479            
    480            uint32  message_id = can_tx_msg->CAN_MsgID; ;
   \       0x14   0x6827             LDR      R7,[R4, #+0]
    481            uint8   priority = can_tx_msg->CAN_MsgPriority; 
   \       0x16   0xF894 0x800F      LDRB     R8,[R4, #+15]
    482            uint8  *in_data_buffer = can_tx_msg->CAN_MsgDataBuffer;
   \       0x1A   0xF114 0x0906      ADDS     R9,R4,#+6
    483            uint8   in_data_length = can_tx_msg->CAN_MsgDataLength;
   \       0x1E   0xF894 0xA00E      LDRB     R10,[R4, #+14]
    484            uint32  id_temp;
    485            uint32  cs_temp = CAN_MB_CS_RTR(can_msg_init_structure.CAN_MsgRTR) | 
    486                              CAN_MB_CS_SRR(can_msg_init_structure.CAN_MsgSRR) |
    487                              CAN_MB_CS_IDE(can_msg_init_structure.CAN_MsgIdLength);
   \       0x22   0xF89D 0xB013      LDRB     R11,[SP, #+19]
   \       0x26   0xEA5F 0x5B0B      LSLS     R11,R11,#+20
   \       0x2A   0xF41B 0x1B80      ANDS     R11,R11,#0x100000
   \       0x2E   0xF89D 0x0012      LDRB     R0,[SP, #+18]
   \       0x32   0x0580             LSLS     R0,R0,#+22
   \       0x34   0xF410 0x0080      ANDS     R0,R0,#0x400000
   \       0x38   0xEA50 0x0B0B      ORRS     R11,R0,R11
   \       0x3C   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \       0x40   0x0540             LSLS     R0,R0,#+21
   \       0x42   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \       0x46   0xEA50 0x0B0B      ORRS     R11,R0,R11
    488            
    489            if(msg_num_temp >= MSG_MAX_NO || in_data_length > 8)
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4E   0x2810             CMP      R0,#+16
   \       0x50   0xDA03             BGE.N    ??LPLD_CAN_TransmitMessage_0
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x56   0x2809             CMP      R0,#+9
   \       0x58   0xDB01             BLT.N    ??LPLD_CAN_TransmitMessage_1
    490            {
    491              return 0; // 超出阈值
   \                     ??LPLD_CAN_TransmitMessage_0: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE047             B.N      ??LPLD_CAN_TransmitMessage_2
    492            }
    493            //如果发送Msg缓冲区中的CODE不等于CAN_MSGOBJ_TX_ONCE
    494            if( LPLD_CAN_GetMsgCode(canx_ptr,msg_num_temp) != CAN_MSGOBJ_TX_ONCE)
   \                     ??LPLD_CAN_TransmitMessage_1: (+1)
   \       0x5E   0x0029             MOVS     R1,R5
   \       0x60   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0x....'....        BL       LPLD_CAN_GetMsgCode
   \       0x68   0x280C             CMP      R0,#+12
   \       0x6A   0xD03E             BEQ.N    ??LPLD_CAN_TransmitMessage_3
    495            {
    496              //设置Msg的ID
    497              if(id_type == CAN_MSGOBJ_ID_STD)
   \       0x6C   0x9801             LDR      R0,[SP, #+4]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD105             BNE.N    ??LPLD_CAN_TransmitMessage_4
    498              {
    499                id_temp =  CAN_MB_ID_STD(message_id);
   \       0x72   0x....'....        LDR.W    R0,??DataTable19_27  ;; 0x1ffc0000
   \       0x76   0xEA10 0x4087      ANDS     R0,R0,R7, LSL #+18
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0xE002             B.N      ??LPLD_CAN_TransmitMessage_5
    500              }
    501              else
    502              {
    503                id_temp =  CAN_MB_ID_EXT(message_id);
   \                     ??LPLD_CAN_TransmitMessage_4: (+1)
   \       0x7E   0xF027 0x4060      BIC      R0,R7,#0xE0000000
   \       0x82   0x9000             STR      R0,[SP, #+0]
    504              }
    505              //向发送Msg缓冲区中的CODE中写INACTIVE命令
    506              canx_ptr->MB[msg_num_temp].CS = CAN_MB_CS_CODE(CAN_MSGOBJ_TX_INACTIVE) | cs_temp;
   \                     ??LPLD_CAN_TransmitMessage_5: (+1)
   \       0x84   0xF05B 0x6000      ORRS     R0,R11,#0x8000000
   \       0x88   0x0029             MOVS     R1,R5
   \       0x8A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x8C   0x0109             LSLS     R1,R1,#+4
   \       0x8E   0x4431             ADD      R1,R6,R1
   \       0x90   0xF8C1 0x0080      STR      R0,[R1, #+128]
    507              canx_ptr->MB[msg_num_temp].ID = CAN_MB_ID_PRIO(priority) | id_temp;
   \       0x94   0x4640             MOV      R0,R8
   \       0x96   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x98   0x9900             LDR      R1,[SP, #+0]
   \       0x9A   0xEA51 0x7140      ORRS     R1,R1,R0, LSL #+29
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xA2   0x0100             LSLS     R0,R0,#+4
   \       0xA4   0x4430             ADD      R0,R6,R0
   \       0xA6   0xF8C0 0x1084      STR      R1,[R0, #+132]
    508              //向Msg中写入要发送的数据
    509              LPLD_CAN_WriteData(canx_ptr,msg_num_temp,in_data_length,in_data_buffer);
   \       0xAA   0x464B             MOV      R3,R9
   \       0xAC   0x4652             MOV      R2,R10
   \       0xAE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xB0   0x0029             MOVS     R1,R5
   \       0xB2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xB4   0x0030             MOVS     R0,R6
   \       0xB6   0x....'....        BL       LPLD_CAN_WriteData
    510              //向发送Msg缓冲区中的CODE中写TX_ONCE命令，等待发送完成
    511              canx_ptr->MB[msg_num_temp].CS = (canx_ptr->MB[msg_num_temp].CS & (~CAN_MB_CS_CODE_MASK)) | 
    512                                               CAN_MB_CS_CODE(CAN_MSGOBJ_TX_ONCE)|
    513                                               CAN_MB_CS_DLC(in_data_length);
   \       0xBA   0x0028             MOVS     R0,R5
   \       0xBC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xBE   0x0100             LSLS     R0,R0,#+4
   \       0xC0   0x4430             ADD      R0,R6,R0
   \       0xC2   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \       0xC6   0xF030 0x6070      BICS     R0,R0,#0xF000000
   \       0xCA   0x4651             MOV      R1,R10
   \       0xCC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xCE   0x0409             LSLS     R1,R1,#+16
   \       0xD0   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \       0xD4   0x4308             ORRS     R0,R1,R0
   \       0xD6   0xF050 0x6040      ORRS     R0,R0,#0xC000000
   \       0xDA   0x0029             MOVS     R1,R5
   \       0xDC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xDE   0x0109             LSLS     R1,R1,#+4
   \       0xE0   0x4431             ADD      R1,R6,R1
   \       0xE2   0xF8C1 0x0080      STR      R0,[R1, #+128]
    514              //如果开启发送中断，发送完毕后会触发中断
    515              request = 1;
   \       0xE6   0x2001             MOVS     R0,#+1
   \       0xE8   0xE000             B.N      ??LPLD_CAN_TransmitMessage_6
    516            }
    517            else
    518            {
    519              request = 0;
   \                     ??LPLD_CAN_TransmitMessage_3: (+1)
   \       0xEA   0x2000             MOVS     R0,#+0
    520            }
    521            return (request);
   \                     ??LPLD_CAN_TransmitMessage_6: (+1)
   \       0xEC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPLD_CAN_TransmitMessage_2: (+1)
   \       0xEE   0xB007             ADD      SP,SP,#+28
   \       0xF0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    522          }
    523          
    524          /*
    525           * LPLD_CAN_ReceivedMessage
    526           * CAN 处理接收函数，此函数一般在CAN中断函数中调用
    527           * 参数:
    528           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    529           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    530           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    531           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    532           *    该结构体用于定义CAN的消息格式，当CAN成功接收消息以后，会从MSG中将信息存储到
    533           *    CAN_MessageFormat_TypeDef定义的结构体对象中。
    534           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    535           *    
    536           *  输出：
    537           *    无
    538           */

   \                                 In section .text, align 2, keep-with-next
    539          void LPLD_CAN_ReceivedMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,\
    540                                        CAN_MessageFormat_TypeDef *can_rx_msg)
    541          {
   \                     LPLD_CAN_ReceivedMessage: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x9C10             LDR      R4,[SP, #+64]
    542            uint32 message_code,i;
    543            volatile uint16 timer;
    544            uint8 rx_data[CAN_DATA_MAX_BYTES];
    545            uint8 data_length;
    546            uint16 time_stamp;
    547            uint32 msg_id;
    548            CAN_Type *canx = can_msg_init_structure.CAN_Canx;
   \        0x8   0xF8DD 0x800C      LDR      R8,[SP, #+12]
    549            uint8 msg_num = can_msg_init_structure.CAN_MsgNum;
   \        0xC   0xF89D 0x9010      LDRB     R9,[SP, #+16]
    550            //获得Msg缓冲区中的code值
    551            message_code = LPLD_CAN_GetMsgCode(canx,msg_num);
   \       0x10   0x4649             MOV      R1,R9
   \       0x12   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x....'....        BL       LPLD_CAN_GetMsgCode
   \       0x1A   0x4682             MOV      R10,R0
    552            
    553            if ((message_code != CAN_MSGOBJ_RX_BUSY) && 
    554               (message_code != CAN_MSGOBJ_RX_OVERRUN))
   \       0x1C   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x20   0xD043             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
   \       0x22   0xF1BA 0x0F06      CMP      R10,#+6
   \       0x26   0xD040             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
    555            {
    556              //读取ID(可选)
    557              msg_id = LPLD_CAN_GetMsgID(canx, msg_num);
   \       0x28   0x4649             MOV      R1,R9
   \       0x2A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x2C   0x4640             MOV      R0,R8
   \       0x2E   0x....'....        BL       LPLD_CAN_GetMsgID
   \       0x32   0x0007             MOVS     R7,R0
    558             
    559              //读取Msg缓冲区接收数据的长度
    560              data_length    = (uint8_t)LPLD_CAN_GetMsgLength(canx, msg_num);
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x....'....        BL       LPLD_CAN_GetMsgLength
   \       0x3E   0x0005             MOVS     R5,R0
    561              //读取Msg缓冲区接收数据
    562              LPLD_CAN_GetData(canx, msg_num,data_length,rx_data);
   \       0x40   0xAB01             ADD      R3,SP,#+4
   \       0x42   0x002A             MOVS     R2,R5
   \       0x44   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x46   0x4649             MOV      R1,R9
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0x4640             MOV      R0,R8
   \       0x4C   0x....'....        BL       LPLD_CAN_GetData
    563              //获得Msg缓冲区时间戳
    564              time_stamp = LPLD_CAN_GetMsgTimeStamp(canx, msg_num);
   \       0x50   0x4649             MOV      R1,R9
   \       0x52   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0x....'....        BL       LPLD_CAN_GetMsgTimeStamp
   \       0x5A   0x0006             MOVS     R6,R0
    565              
    566              for(i = data_length; i < 8; i++)
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x60   0x4683             MOV      R11,R0
   \                     ??LPLD_CAN_ReceivedMessage_1: (+1)
   \       0x62   0xF1BB 0x0F08      CMP      R11,#+8
   \       0x66   0xD206             BCS.N    ??LPLD_CAN_ReceivedMessage_2
    567              {
    568                 rx_data[i] = 0;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xA901             ADD      R1,SP,#+4
   \       0x6C   0xF801 0x000B      STRB     R0,[R1, R11]
    569              }
   \       0x70   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \       0x74   0xE7F5             B.N      ??LPLD_CAN_ReceivedMessage_1
    570              //将MSG中的消息存储到can_rx_msg中
    571              can_rx_msg->CAN_MsgID = msg_id;
   \                     ??LPLD_CAN_ReceivedMessage_2: (+1)
   \       0x76   0x6027             STR      R7,[R4, #+0]
    572              can_rx_msg->CAN_MsgDataLength = data_length;
   \       0x78   0x73A5             STRB     R5,[R4, #+14]
    573              can_rx_msg->CAN_MsgTimeStamp  = time_stamp;
   \       0x7A   0x80A6             STRH     R6,[R4, #+4]
    574              memcpy(can_rx_msg->CAN_MsgDataBuffer,rx_data,data_length);
   \       0x7C   0x002A             MOVS     R2,R5
   \       0x7E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x80   0xA901             ADD      R1,SP,#+4
   \       0x82   0x1DA0             ADDS     R0,R4,#+6
   \       0x84   0x....'....        BL       memcpy
    575               
    576              //读取自由计数器，解锁当前Msg缓冲区
    577              timer = LPLD_CAN_UnlockMsg(canx);
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0x....'....        BL       LPLD_CAN_UnlockMsg
   \       0x8E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    578              //清空Msg缓冲区的中断标志位
    579              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \       0x92   0x4649             MOV      R1,R9
   \       0x94   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x96   0x4640             MOV      R0,R8
   \       0x98   0x....'....        BL       LPLD_CAN_Interrupt_ClearPending
    580              //再次写邮箱的code为empty状态
    581              LPLD_CAN_SetMsgCode(canx,msg_num,CAN_MSGOBJ_RX_EMPTY);
   \       0x9C   0x2204             MOVS     R2,#+4
   \       0x9E   0x4649             MOV      R1,R9
   \       0xA0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xA2   0x4640             MOV      R0,R8
   \       0xA4   0x....'....        BL       LPLD_CAN_SetMsgCode
   \       0xA8   0xE009             B.N      ??LPLD_CAN_ReceivedMessage_3
    582            }
    583            else
    584            {
    585              //接收邮箱溢出
    586              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_ReceivedMessage_0: (+1)
   \       0xAA   0x4649             MOV      R1,R9
   \       0xAC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xAE   0x4640             MOV      R0,R8
   \       0xB0   0x....'....        BL       LPLD_CAN_Interrupt_ClearPending
    587              //读取自由计数器，解锁当前Msg缓冲区
    588              timer = LPLD_CAN_UnlockMsg(canx);
   \       0xB4   0x4640             MOV      R0,R8
   \       0xB6   0x....'....        BL       LPLD_CAN_UnlockMsg
   \       0xBA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    589            }
    590          }
   \                     ??LPLD_CAN_ReceivedMessage_3: (+1)
   \       0xBE   0xB007             ADD      SP,SP,#+28
   \       0xC0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    591          
    592          /*
    593           * LPLD_CAN_Interrupt_ClearPending
    594           * 清除Msg的中断标志位
    595           * 参数:
    596           *    CAN_Type *canx
    597           *      |___ CAN0 --CAN0号模块
    598           *      |___ CAN1 --CAN1号模块
    599           *    msg_num 选择要清除中断标志的Msg缓冲区
    600           *      |___ MSG_NUM_0 --Msg缓冲区0
    601           *      |___ MSG_NUM_1 --Msg缓冲区1
    602           *      |___ MSG_NUM_2 --Msg缓冲区2
    603           *      |___ MSG_NUM_3 --Msg缓冲区3
    604           *      |___ MSG_NUM_4 --Msg缓冲区4
    605           *      ...... 
    606           *      |___ MSG_NUM_15 --Msg缓冲区15
    607           * 输出:
    608           *   无
    609           */

   \                                 In section .text, align 2, keep-with-next
    610          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *canx, uint8 msg_num)
    611          {   
   \                     LPLD_CAN_Interrupt_ClearPending: (+1)
   \        0x0   0xB410             PUSH     {R4}
    612            if(msg_num < 32)
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x6   0x2A20             CMP      R2,#+32
   \        0x8   0xDA05             BGE.N    ??LPLD_CAN_Interrupt_ClearPending_0
    613            {
    614              canx->IFLAG1 |= (1<<msg_num); 
   \        0xA   0x6B02             LDR      R2,[R0, #+48]
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x408B             LSLS     R3,R3,R1
   \       0x10   0x431A             ORRS     R2,R3,R2
   \       0x12   0x6302             STR      R2,[R0, #+48]
   \       0x14   0xE006             B.N      ??LPLD_CAN_Interrupt_ClearPending_1
    615            }
    616            else
    617            {
    618              canx->IFLAG2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_Interrupt_ClearPending_0: (+1)
   \       0x16   0x6AC3             LDR      R3,[R0, #+44]
   \       0x18   0x2401             MOVS     R4,#+1
   \       0x1A   0xF1B1 0x0220      SUBS     R2,R1,#+32
   \       0x1E   0x4094             LSLS     R4,R4,R2
   \       0x20   0x4323             ORRS     R3,R4,R3
   \       0x22   0x62C3             STR      R3,[R0, #+44]
    619            }
    620          }
   \                     ??LPLD_CAN_Interrupt_ClearPending_1: (+1)
   \       0x24   0xBC10             POP      {R4}
   \       0x26   0x4770             BX       LR               ;; return
    621          
    622          /*
    623           * LPLD_CAN_Interrupt_GetFlag
    624           * 获得CAN 的中断标志位
    625           * 参数:
    626           *    CAN_Type *canx
    627           *      |___ CAN0 --CAN0号模块
    628           *      |___ CAN1 --CAN1号模块
    629           *    msg_num 选择要获得中断标志的Msg缓冲区
    630           *      |___ MSG_NUM_0 --Msg缓冲区0
    631           *      |___ MSG_NUM_1 --Msg缓冲区1
    632           *      |___ MSG_NUM_2 --Msg缓冲区2
    633           *      |___ MSG_NUM_3 --Msg缓冲区3
    634           *      |___ MSG_NUM_4 --Msg缓冲区4
    635           *      ...... 
    636           *      |___ MSG_NUM_15 --Msg缓冲区15
    637           * 输出:
    638           *    返回需要 Msg缓冲区的中断标志位
    639           */

   \                                 In section .text, align 2, keep-with-next
    640          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *canx, uint8 msg_num)
    641          {   
   \                     LPLD_CAN_Interrupt_GetFlag: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    642            uint8 status;
    643            if(msg_num < 32)
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x6   0x2820             CMP      R0,#+32
   \        0x8   0xDA04             BGE.N    ??LPLD_CAN_Interrupt_GetFlag_0
    644            {
    645              status = (canx->IFLAG1 >> msg_num) & 0x01; 
   \        0xA   0x6B10             LDR      R0,[R2, #+48]
   \        0xC   0x40C8             LSRS     R0,R0,R1
   \        0xE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x12   0xE005             B.N      ??LPLD_CAN_Interrupt_GetFlag_1
    646            }
    647            else
    648            {
    649              status = (canx->IFLAG2 >> (msg_num - 32) )& 0x01; 
   \                     ??LPLD_CAN_Interrupt_GetFlag_0: (+1)
   \       0x14   0x6AD0             LDR      R0,[R2, #+44]
   \       0x16   0xF1B1 0x0320      SUBS     R3,R1,#+32
   \       0x1A   0x40D8             LSRS     R0,R0,R3
   \       0x1C   0xF010 0x0001      ANDS     R0,R0,#0x1
    650            }
    651            return status;
   \                     ??LPLD_CAN_Interrupt_GetFlag_1: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x22   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /*
    655           * LPLD_CAN_UnlockMsg
    656           * 该函数通过读取自由计数器，解锁Msg
    657           * 参数:
    658           *    canx--设置CAN总线通道
    659           *      |__CAN0 --CAN0号模块
    660           *      |__CAN1 --CAN1号模块
    661           * 输出:
    662           *    16位CAN自由计数器记录的时间戳
    663           */

   \                                 In section .text, align 2, keep-with-next
    664          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *canx)
    665          {
    666            return (canx->TIMER);
   \                     LPLD_CAN_UnlockMsg: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x4   0x4770             BX       LR               ;; return
    667          }
    668          
    669          /*
    670           * LPLD_CAN_EnableMsgInterrupt
    671           * 该函数用于使能Msg中断
    672           * 
    673           * 参数:
    674           *    canx--设置CAN总线通道
    675           *      |__CAN0 --CAN0号模块
    676           *      |__CAN1 --CAN1号模块
    677           *    msg_num 选择需要使能中断的Msg缓冲区
    678           *      |___ MSG_NUM_0 --Msg缓冲区0
    679           *      |___ MSG_NUM_1 --Msg缓冲区1
    680           *      |___ MSG_NUM_2 --Msg缓冲区2
    681           *      |___ MSG_NUM_3 --Msg缓冲区3
    682           *      |___ MSG_NUM_4 --Msg缓冲区4
    683           *      ...... 
    684           *      |___ MSG_NUM_15 --Msg缓冲区15
    685           * 输出:
    686           *    无
    687           *
    688           */

   \                                 In section .text, align 2, keep-with-next
    689          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *canx, uint8 msg_num)
    690          {
   \                     LPLD_CAN_EnableMsgInterrupt: (+1)
   \        0x0   0xB410             PUSH     {R4}
    691            if(msg_num < 32)
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x6   0x2A20             CMP      R2,#+32
   \        0x8   0xDA05             BGE.N    ??LPLD_CAN_EnableMsgInterrupt_0
    692            {
    693              canx->IMASK1 |= (1<<msg_num); 
   \        0xA   0x6A82             LDR      R2,[R0, #+40]
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x408B             LSLS     R3,R3,R1
   \       0x10   0x431A             ORRS     R2,R3,R2
   \       0x12   0x6282             STR      R2,[R0, #+40]
   \       0x14   0xE006             B.N      ??LPLD_CAN_EnableMsgInterrupt_1
    694            }
    695            else
    696            {
    697              canx->IMASK2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_EnableMsgInterrupt_0: (+1)
   \       0x16   0x6A43             LDR      R3,[R0, #+36]
   \       0x18   0x2401             MOVS     R4,#+1
   \       0x1A   0xF1B1 0x0220      SUBS     R2,R1,#+32
   \       0x1E   0x4094             LSLS     R4,R4,R2
   \       0x20   0x4323             ORRS     R3,R4,R3
   \       0x22   0x6243             STR      R3,[R0, #+36]
    698            }
    699          }
   \                     ??LPLD_CAN_EnableMsgInterrupt_1: (+1)
   \       0x24   0xBC10             POP      {R4}
   \       0x26   0x4770             BX       LR               ;; return
    700          
    701          /*
    702           * LPLD_CAN_SetMsgCode
    703           * 该函数用于设置Msg的code值
    704           * 
    705           * 参数:
    706           *    canx--设置CAN总线通道
    707           *      |__CAN0 --CAN0号模块
    708           *      |__CAN1 --CAN1号模块
    709           *    msg_num 选择需要设置CODE的Msg缓冲区
    710           *      |___ MSG_NUM_0 --Msg缓冲区0
    711           *      |___ MSG_NUM_1 --Msg缓冲区1
    712           *      |___ MSG_NUM_2 --Msg缓冲区2
    713           *      |___ MSG_NUM_3 --Msg缓冲区3
    714           *      |___ MSG_NUM_4 --Msg缓冲区4
    715           *      ...... 
    716           *      |___ MSG_NUM_15 --Msg缓冲区15
    717           *    code--需要设置的code值
    718           * 输出:
    719           *    无
    720           *
    721           */

   \                                 In section .text, align 2, keep-with-next
    722          static void LPLD_CAN_SetMsgCode(CAN_Type *canx, uint8 msg_num, uint8 code)
    723          {
   \                     LPLD_CAN_SetMsgCode: (+1)
   \        0x0   0xB410             PUSH     {R4}
    724            //canx->MB[msg_num].CS &= (~CAN_MB_CS_CODE_MASK);
    725            canx->MB[msg_num].CS |= CAN_MB_CS_CODE(code);
   \        0x2   0x000B             MOVS     R3,R1
   \        0x4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \        0x6   0x011B             LSLS     R3,R3,#+4
   \        0x8   0x4403             ADD      R3,R0,R3
   \        0xA   0xF8D3 0x3080      LDR      R3,[R3, #+128]
   \        0xE   0x0014             MOVS     R4,R2
   \       0x10   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x12   0x0624             LSLS     R4,R4,#+24
   \       0x14   0xF014 0x6470      ANDS     R4,R4,#0xF000000
   \       0x18   0x4323             ORRS     R3,R4,R3
   \       0x1A   0x000C             MOVS     R4,R1
   \       0x1C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x1E   0x0124             LSLS     R4,R4,#+4
   \       0x20   0x4404             ADD      R4,R0,R4
   \       0x22   0xF8C4 0x3080      STR      R3,[R4, #+128]
    726          }
   \       0x26   0xBC10             POP      {R4}
   \       0x28   0x4770             BX       LR               ;; return
    727          
    728          /*
    729           * LPLD_CAN_GetMsgCode
    730           * 该函数用于获得Msg缓冲区的code值
    731           * 
    732           * 参数:
    733           *    canx--设置CAN总线通道
    734           *      |__CAN0 --CAN0号模块
    735           *      |__CAN1 --CAN1号模块
    736           *    msg_num 选择需要获得CODE的Msg缓冲区
    737           *      |___ MSG_NUM_0 --Msg缓冲区0
    738           *      |___ MSG_NUM_1 --Msg缓冲区1
    739           *      |___ MSG_NUM_2 --Msg缓冲区2
    740           *      |___ MSG_NUM_3 --Msg缓冲区3
    741           *      |___ MSG_NUM_4 --Msg缓冲区4
    742           *      ...... 
    743           *      |___ MSG_NUM_15 --Msg缓冲区15
    744           * 输出:
    745           *     返回相应Msg缓冲区的code
    746           *
    747           */

   \                                 In section .text, align 2, keep-with-next
    748          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *canx, uint8 msg_num)
    749          {
    750             return CAN_GET_MB_CS_CODE(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgCode: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x0109             LSLS     R1,R1,#+4
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \        0xA   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \        0xE   0x4770             BX       LR               ;; return
    751          }
    752          /*
    753           * LPLD_CAN_GetMsgTimeStamp
    754           * 该函数用于获得Msg缓冲区的时间戳
    755           * 
    756           * 参数:
    757           *    canx--设置CAN总线通道
    758           *      |__CAN0 --CAN0号模块
    759           *      |__CAN1 --CAN1号模块
    760           *    msg_num 选择需要获得时间戳的Msg缓冲区
    761           *      |___ MSG_NUM_0 --Msg缓冲区0
    762           *      |___ MSG_NUM_1 --Msg缓冲区1
    763           *      |___ MSG_NUM_2 --Msg缓冲区2
    764           *      |___ MSG_NUM_3 --Msg缓冲区3
    765           *      |___ MSG_NUM_4 --Msg缓冲区4
    766           *      ...... 
    767           *      |___ MSG_NUM_15 --Msg缓冲区15
    768           * 输出:
    769           *     返回相应Msg缓冲区的时间戳
    770           *
    771           */

   \                                 In section .text, align 2, keep-with-next
    772          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *canx, uint8 msg_num)
    773          {
    774            return CAN_GET_MB_CS_TIMESTAMP(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgTimeStamp: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x0109             LSLS     R1,R1,#+4
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \        0xA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0xC   0x4770             BX       LR               ;; return
    775          }
    776          /*
    777           * LPLD_CAN_GetMsgID
    778           * 该函数用于获得Msg缓冲区的ID值
    779           * 
    780           * 参数:
    781           *    canx--设置CAN总线通道
    782           *      |__CAN0 --CAN0号模块
    783           *      |__CAN1 --CAN1号模块
    784           *    msg_num 选择需要获得ID的Msg缓冲区
    785           *      |___ MSG_NUM_0 --Msg缓冲区0
    786           *      |___ MSG_NUM_1 --Msg缓冲区1
    787           *      |___ MSG_NUM_2 --Msg缓冲区2
    788           *      |___ MSG_NUM_3 --Msg缓冲区3
    789           *      |___ MSG_NUM_4 --Msg缓冲区4
    790           *      ...... 
    791           *      |___ MSG_NUM_15 --Msg缓冲区15
    792           * 输出:
    793           *     返回相应Msg缓冲区的ID
    794           *
    795           */

   \                                 In section .text, align 2, keep-with-next
    796          static uint32 LPLD_CAN_GetMsgID(CAN_Type *canx, uint8 msg_num)
    797          {
   \                     LPLD_CAN_GetMsgID: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    798            uint32 id_temp;
    799            if(CAN_GET_MB_CS_IDE(canx->MB[msg_num].CS) == CAN_MSGOBJ_ID_STD)
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x6   0x0100             LSLS     R0,R0,#+4
   \        0x8   0x4410             ADD      R0,R2,R0
   \        0xA   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \        0xE   0xF3C0 0x5040      UBFX     R0,R0,#+21,#+1
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD108             BNE.N    ??LPLD_CAN_GetMsgID_0
    800            {
    801              id_temp =  CAN_GET_MB_ID_STD(canx->MB[msg_num].ID);
   \       0x16   0x0008             MOVS     R0,R1
   \       0x18   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1A   0x0100             LSLS     R0,R0,#+4
   \       0x1C   0x4410             ADD      R0,R2,R0
   \       0x1E   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \       0x22   0xF3C0 0x408A      UBFX     R0,R0,#+18,#+11
   \       0x26   0xE007             B.N      ??LPLD_CAN_GetMsgID_1
    802            }
    803            else
    804            {
    805              id_temp =  CAN_GET_MB_ID_EXT(canx->MB[msg_num].ID);
   \                     ??LPLD_CAN_GetMsgID_0: (+1)
   \       0x28   0x0008             MOVS     R0,R1
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x0100             LSLS     R0,R0,#+4
   \       0x2E   0x4410             ADD      R0,R2,R0
   \       0x30   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \       0x34   0xF020 0x4060      BIC      R0,R0,#0xE0000000
    806            }
    807            return id_temp;
   \                     ??LPLD_CAN_GetMsgID_1: (+1)
   \       0x38   0x4770             BX       LR               ;; return
    808          }
    809          /*
    810           * LPLD_CAN_GetMsgLength
    811           * 该函数用于获得Msg缓冲区的数据长度
    812           * 
    813           * 参数:
    814           *    canx--设置CAN总线通道
    815           *      |__CAN0 --CAN0号模块
    816           *      |__CAN1 --CAN1号模块
    817           *    msg_num 选择需要获得数据长度的Msg缓冲区
    818           *      |___ MSG_NUM_0 --Msg缓冲区0
    819           *      |___ MSG_NUM_1 --Msg缓冲区1
    820           *      |___ MSG_NUM_2 --Msg缓冲区2
    821           *      |___ MSG_NUM_3 --Msg缓冲区3
    822           *      |___ MSG_NUM_4 --Msg缓冲区4
    823           *      ...... 
    824           *      |___ MSG_NUM_15 --Msg缓冲区15
    825           * 输出:
    826           *     数据的长度
    827           *
    828           */

   \                                 In section .text, align 2, keep-with-next
    829          static uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 msg_num)
    830          {
    831            return CAN_GET_MB_CS_LENGTH(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgLength: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x0109             LSLS     R1,R1,#+4
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \        0xA   0x0C00             LSRS     R0,R0,#+16
   \        0xC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x10   0x4770             BX       LR               ;; return
    832          }
    833          
    834          /*
    835           * LPLD_CAN_GetData
    836           * 该函数用于获得Msg缓冲区中的数据
    837           * 
    838           * 参数:
    839           *    canx--设置CAN总线通道
    840           *      |__CAN0 --CAN0号模块
    841           *      |__CAN1 --CAN1号模块
    842           *    msg_num 选择需要获得数据的Msg缓冲区
    843           *      |___ MSG_NUM_0 --Msg缓冲区0
    844           *      |___ MSG_NUM_1 --Msg缓冲区1
    845           *      |___ MSG_NUM_2 --Msg缓冲区2
    846           *      |___ MSG_NUM_3 --Msg缓冲区3
    847           *      |___ MSG_NUM_4 --Msg缓冲区4
    848           *      ...... 
    849           *      |___ MSG_NUM_15 --Msg缓冲区15
    850           *    in_length
    851           *      |__获得数据长度
    852           *    *in_buffer
    853           *      |__获得数据的缓冲区
    854           * 输出:
    855           *    无 
    856           */

   \                                 In section .text, align 2, keep-with-next
    857          static void LPLD_CAN_GetData(
    858              CAN_Type *canx, 
    859              uint8     msg_num, 
    860              uint8     in_length, 
    861              uint8    *in_buffer)
    862          {
   \                     LPLD_CAN_GetData: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
    863            int i;
    864            uint8  *pMBData;
    865            uint8  *pRecieve  = in_buffer;
   \        0x6   0x001E             MOVS     R6,R3
    866            uint8  word_num   = (in_length - 1)/ 4; //Get the Message buffer word number
   \        0x8   0x0010             MOVS     R0,R2
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \        0xE   0x2704             MOVS     R7,#+4
   \       0x10   0xFB90 0xF7F7      SDIV     R7,R0,R7
    867            uint8  rest_bytes = (in_length - 1)% 4; //Get the reset bytes of buffer
   \       0x14   0x0010             MOVS     R0,R2
   \       0x16   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0xF05F 0x0E04      MOVS     LR,#+4
   \       0x1E   0xFB90 0xFCFE      SDIV     R12,R0,LR
   \       0x22   0xFB0E 0x0C1C      MLS      R12,LR,R12,R0
    868            if(word_num > 0)
   \       0x26   0x0038             MOVS     R0,R7
   \       0x28   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD019             BEQ.N    ??LPLD_CAN_GetData_0
    869            {  
    870              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \       0x2E   0x0008             MOVS     R0,R1
   \       0x30   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x32   0x0100             LSLS     R0,R0,#+4
   \       0x34   0x4420             ADD      R0,R4,R0
   \       0x36   0x308B             ADDS     R0,R0,#+139
    871              for(i = 0 ; i < 4 ; i++)   
   \       0x38   0xF05F 0x0E00      MOVS     LR,#+0
   \       0x3C   0x4675             MOV      R5,LR
   \                     ??LPLD_CAN_GetData_1: (+1)
   \       0x3E   0x2D04             CMP      R5,#+4
   \       0x40   0xDA06             BGE.N    ??LPLD_CAN_GetData_2
    872              {
    873                pRecieve[i] = *pMBData--;
   \       0x42   0xF890 0xE000      LDRB     LR,[R0, #+0]
   \       0x46   0xF806 0xE005      STRB     LR,[R6, R5]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
    874              }
   \       0x4C   0x1C6D             ADDS     R5,R5,#+1
   \       0x4E   0xE7F6             B.N      ??LPLD_CAN_GetData_1
    875              pMBData = (uint8*)&canx->MB[msg_num].WORD1+3;
   \                     ??LPLD_CAN_GetData_2: (+1)
   \       0x50   0x468E             MOV      LR,R1
   \       0x52   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0x56   0xEA5F 0x1E0E      LSLS     LR,LR,#+4
   \       0x5A   0x44A6             ADD      LR,R4,LR
   \       0x5C   0xF11E 0x0E8F      ADDS     LR,LR,#+143
   \       0x60   0xE005             B.N      ??LPLD_CAN_GetData_3
    876            }
    877            else
    878            {
    879              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \                     ??LPLD_CAN_GetData_0: (+1)
   \       0x62   0x0008             MOVS     R0,R1
   \       0x64   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x66   0x0100             LSLS     R0,R0,#+4
   \       0x68   0x4420             ADD      R0,R4,R0
   \       0x6A   0xF110 0x0E8B      ADDS     LR,R0,#+139
    880            }
    881          
    882            for(i = 0; i <= rest_bytes; i++)
   \                     ??LPLD_CAN_GetData_3: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \                     ??LPLD_CAN_GetData_4: (+1)
   \       0x70   0x4665             MOV      R5,R12
   \       0x72   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0x74   0x4285             CMP      R5,R0
   \       0x76   0xDB0B             BLT.N    ??LPLD_CAN_GetData_5
    883            {
    884              pRecieve[i+(word_num<<2)] = *pMBData--;    
   \       0x78   0x003D             MOVS     R5,R7
   \       0x7A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0x7C   0xEB10 0x0585      ADDS     R5,R0,R5, LSL #+2
   \       0x80   0xF89E 0x8000      LDRB     R8,[LR, #+0]
   \       0x84   0xF806 0x8005      STRB     R8,[R6, R5]
   \       0x88   0xF1BE 0x0E01      SUBS     LR,LR,#+1
    885            }
   \       0x8C   0x1C40             ADDS     R0,R0,#+1
   \       0x8E   0xE7EF             B.N      ??LPLD_CAN_GetData_4
    886          }
   \                     ??LPLD_CAN_GetData_5: (+1)
   \       0x90   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    887          
    888          /*
    889           * LPLD_CAN_WriteData
    890           * 该函数用于向Msg缓冲区中的写数据
    891           * 
    892           * 参数:
    893           *    canx--设置CAN总线通道
    894           *      |__CAN0 --CAN0号模块
    895           *      |__CAN1 --CAN1号模块
    896           *    msg_num 选择需要写数据的Msg缓冲区
    897           *      |___ MSG_NUM_0 --Msg缓冲区0
    898           *      |___ MSG_NUM_1 --Msg缓冲区1
    899           *      |___ MSG_NUM_2 --Msg缓冲区2
    900           *      |___ MSG_NUM_3 --Msg缓冲区3
    901           *      |___ MSG_NUM_4 --Msg缓冲区4
    902           *      ...... 
    903           *      |___ MSG_NUM_15 --Msg缓冲区15
    904           *    in_length
    905           *      |__写入数据长度
    906           *    *in_buffer
    907           *      |__写入数据的缓冲区
    908           * 输出:
    909           *    无 
    910           */

   \                                 In section .text, align 2, keep-with-next
    911          static void LPLD_CAN_WriteData(
    912              CAN_Type *canx, 
    913              uint8     msg_num, 
    914              uint8     in_length, 
    915              uint8    *in_buffer )
    916          {
   \                     LPLD_CAN_WriteData: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    917            int i;
    918            uint32 word[2] = {0};  
   \        0x4   0x466C             MOV      R4,SP
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0xE9C4 0x5600      STRD     R5,R6,[R4, #+0]
    919            uint8  word_num   = (in_length - 1)/ 4; //获得 Msg 的Word 值
   \        0xE   0x0014             MOVS     R4,R2
   \       0x10   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x12   0x1E64             SUBS     R4,R4,#+1
   \       0x14   0x2504             MOVS     R5,#+4
   \       0x16   0xFB94 0xF5F5      SDIV     R5,R4,R5
    920            uint8  rest_bytes = (in_length - 1)% 4; //获得剩余字节的值
   \       0x1A   0x0016             MOVS     R6,R2
   \       0x1C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x1E   0x1E76             SUBS     R6,R6,#+1
   \       0x20   0x2704             MOVS     R7,#+4
   \       0x22   0xFB96 0xF4F7      SDIV     R4,R6,R7
   \       0x26   0xFB07 0x6414      MLS      R4,R7,R4,R6
    921          
    922            if( msg_num >= MSG_MAX_NO || in_length >8)
   \       0x2A   0x000E             MOVS     R6,R1
   \       0x2C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x2E   0x2E10             CMP      R6,#+16
   \       0x30   0xDA03             BGE.N    ??LPLD_CAN_WriteData_0
   \       0x32   0x0016             MOVS     R6,R2
   \       0x34   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x36   0x2E09             CMP      R6,#+9
   \       0x38   0xDB00             BLT.N    ??LPLD_CAN_WriteData_1
    923            {
    924                return; 
   \                     ??LPLD_CAN_WriteData_0: (+1)
   \       0x3A   0xE06E             B.N      ??LPLD_CAN_WriteData_2
    925            }
    926          
    927            if(word_num < 1)
   \                     ??LPLD_CAN_WriteData_1: (+1)
   \       0x3C   0x002E             MOVS     R6,R5
   \       0x3E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x40   0x2E00             CMP      R6,#+0
   \       0x42   0xD11B             BNE.N    ??LPLD_CAN_WriteData_3
    928            {
    929              for (i = 0; i <= rest_bytes ; i++)
   \       0x44   0x2600             MOVS     R6,#+0
   \                     ??LPLD_CAN_WriteData_4: (+1)
   \       0x46   0x0027             MOVS     R7,R4
   \       0x48   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x4A   0x42B7             CMP      R7,R6
   \       0x4C   0xDB53             BLT.N    ??LPLD_CAN_WriteData_5
    930              {
    931                word[word_num] |=  (uint32)in_buffer[i] << (24-(i<<3));
   \       0x4E   0x466F             MOV      R7,SP
   \       0x50   0x46AC             MOV      R12,R5
   \       0x52   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0x56   0xF857 0xC02C      LDR      R12,[R7, R12, LSL #+2]
   \       0x5A   0xF813 0xE006      LDRB     LR,[R3, R6]
   \       0x5E   0xEA5F 0x08C6      LSLS     R8,R6,#+3
   \       0x62   0xF1D8 0x0818      RSBS     R8,R8,#+24
   \       0x66   0xFA1E 0xFE08      LSLS     LR,LR,R8
   \       0x6A   0xEA5E 0x0C0C      ORRS     R12,LR,R12
   \       0x6E   0x46AE             MOV      LR,R5
   \       0x70   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0x74   0xF847 0xC02E      STR      R12,[R7, LR, LSL #+2]
    932              }
   \       0x78   0x1C76             ADDS     R6,R6,#+1
   \       0x7A   0xE7E4             B.N      ??LPLD_CAN_WriteData_4
    933            }
    934            else
    935            {
    936              for (i = 0; i < 4; i++)
   \                     ??LPLD_CAN_WriteData_3: (+1)
   \       0x7C   0x2700             MOVS     R7,#+0
   \                     ??LPLD_CAN_WriteData_6: (+1)
   \       0x7E   0x2F04             CMP      R7,#+4
   \       0x80   0xDA1B             BGE.N    ??LPLD_CAN_WriteData_7
    937              {
    938                word[word_num-1] |= (uint32)in_buffer[i] << (24-(i<<3));
   \       0x82   0x466E             MOV      R6,SP
   \       0x84   0x46AC             MOV      R12,R5
   \       0x86   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0x8A   0xEB06 0x068C      ADD      R6,R6,R12, LSL #+2
   \       0x8E   0xF856 0x6C04      LDR      R6,[R6, #-4]
   \       0x92   0xF813 0xC007      LDRB     R12,[R3, R7]
   \       0x96   0xEA5F 0x0EC7      LSLS     LR,R7,#+3
   \       0x9A   0xF1DE 0x0E18      RSBS     LR,LR,#+24
   \       0x9E   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \       0xA2   0xEA5C 0x0606      ORRS     R6,R12,R6
   \       0xA6   0x46EC             MOV      R12,SP
   \       0xA8   0x46AE             MOV      LR,R5
   \       0xAA   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0xAE   0xEB0C 0x0C8E      ADD      R12,R12,LR, LSL #+2
   \       0xB2   0xF84C 0x6C04      STR      R6,[R12, #-4]
    939              }
   \       0xB6   0x1C7F             ADDS     R7,R7,#+1
   \       0xB8   0xE7E1             B.N      ??LPLD_CAN_WriteData_6
    940              for (i = 0; i <= rest_bytes ; i++)
   \                     ??LPLD_CAN_WriteData_7: (+1)
   \       0xBA   0x2600             MOVS     R6,#+0
   \                     ??LPLD_CAN_WriteData_8: (+1)
   \       0xBC   0x0027             MOVS     R7,R4
   \       0xBE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0xC0   0x42B7             CMP      R7,R6
   \       0xC2   0xDB18             BLT.N    ??LPLD_CAN_WriteData_5
    941              {
    942                word[word_num] |=  (uint32)in_buffer[i+4] << (24-(i<<3));
   \       0xC4   0x466F             MOV      R7,SP
   \       0xC6   0x46AC             MOV      R12,R5
   \       0xC8   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0xCC   0xF857 0xC02C      LDR      R12,[R7, R12, LSL #+2]
   \       0xD0   0xEB03 0x0E06      ADD      LR,R3,R6
   \       0xD4   0xF89E 0xE004      LDRB     LR,[LR, #+4]
   \       0xD8   0xEA5F 0x08C6      LSLS     R8,R6,#+3
   \       0xDC   0xF1D8 0x0818      RSBS     R8,R8,#+24
   \       0xE0   0xFA1E 0xFE08      LSLS     LR,LR,R8
   \       0xE4   0xEA5E 0x0C0C      ORRS     R12,LR,R12
   \       0xE8   0x46AE             MOV      LR,R5
   \       0xEA   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \       0xEE   0xF847 0xC02E      STR      R12,[R7, LR, LSL #+2]
    943              }
   \       0xF2   0x1C76             ADDS     R6,R6,#+1
   \       0xF4   0xE7E2             B.N      ??LPLD_CAN_WriteData_8
    944            }
    945            canx->MB[msg_num].WORD0 = word[0];
   \                     ??LPLD_CAN_WriteData_5: (+1)
   \       0xF6   0x9F00             LDR      R7,[SP, #+0]
   \       0xF8   0x468C             MOV      R12,R1
   \       0xFA   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0xFE   0xEA5F 0x1C0C      LSLS     R12,R12,#+4
   \      0x102   0x4484             ADD      R12,R0,R12
   \      0x104   0xF8CC 0x7088      STR      R7,[R12, #+136]
    946            canx->MB[msg_num].WORD1 = word[1];
   \      0x108   0x9F01             LDR      R7,[SP, #+4]
   \      0x10A   0x468C             MOV      R12,R1
   \      0x10C   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \      0x110   0xEA5F 0x1C0C      LSLS     R12,R12,#+4
   \      0x114   0x4484             ADD      R12,R0,R12
   \      0x116   0xF8CC 0x708C      STR      R7,[R12, #+140]
    947          }
   \                     ??LPLD_CAN_WriteData_2: (+1)
   \      0x11A   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    948          
    949          /*
    950           * LPLD_CAN_Transmit_Interrupt
    951           * 该函数用于处理Msg缓冲区发送中断函数
    952           * 
    953           * 参数:
    954           *    canx--设置CAN总线通道
    955           *      |__CAN0 --CAN0号模块
    956           *      |__CAN1 --CAN1号模块
    957           *    msg_num 选择需要处理发送中断的Msg缓冲区
    958           *      |___ MSG_NUM_0 --Msg缓冲区0
    959           *      |___ MSG_NUM_1 --Msg缓冲区1
    960           *      |___ MSG_NUM_2 --Msg缓冲区2
    961           *      |___ MSG_NUM_3 --Msg缓冲区3
    962           *      |___ MSG_NUM_4 --Msg缓冲区4
    963           *      ...... 
    964           *      |___ MSG_NUM_15 --Msg缓冲区15
    965           * 输出:
    966           *    无 
    967           */

   \                                 In section .text, align 2, keep-with-next
    968          void LPLD_CAN_Transmit_Interrupt(CAN_Type *canx, uint8 msg_num)
    969          {
   \                     LPLD_CAN_Transmit_Interrupt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    970            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num))
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x....'....        BL       LPLD_CAN_Interrupt_GetFlag
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD023             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    971            {
    972             LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x....'....        BL       LPLD_CAN_Interrupt_ClearPending
    973             if(canx == CAN0)
   \       0x1E   0x....             LDR.N    R0,??DataTable19_5  ;; 0x40024000
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD10C             BNE.N    ??LPLD_CAN_Transmit_Interrupt_1
    974             {
    975              if( CAN0_ISR[msg_num] != NULL)
   \       0x24   0x....             LDR.N    R1,??DataTable19_28
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD014             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    976              {
    977                CAN0_ISR[msg_num]();
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x36   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x3A   0x4780             BLX      R0
   \       0x3C   0xE00E             B.N      ??LPLD_CAN_Transmit_Interrupt_0
    978              }
    979             }
    980             else if (canx == CAN1)
   \                     ??LPLD_CAN_Transmit_Interrupt_1: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable19_26  ;; 0x400a4000
   \       0x40   0x4284             CMP      R4,R0
   \       0x42   0xD10B             BNE.N    ??LPLD_CAN_Transmit_Interrupt_0
    981             {
    982              if( CAN1_ISR[msg_num] != NULL)
   \       0x44   0x....             LDR.N    R1,??DataTable19_29
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD004             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    983              {
    984                CAN1_ISR[msg_num]();
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x56   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x5A   0x4780             BLX      R0
    985              }
    986             }
    987             else
    988             {
    989             }
    990             
    991            }
    992          }
   \                     ??LPLD_CAN_Transmit_Interrupt_0: (+1)
   \       0x5C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    993          
    994          /*
    995           * LPLD_CAN_Receive_Interrupt
    996           * 该函数用于处理Msg缓冲区接收中断函数
    997           * 
    998           * 参数:
    999           *    canx--设置CAN总线通道
   1000           *      |__CAN0 --CAN0号模块
   1001           *      |__CAN1 --CAN1号模块
   1002           *    msg_num 选择需要处理接收中断的Msg缓冲区
   1003           *      |___ MSG_NUM_0 --Msg缓冲区0
   1004           *      |___ MSG_NUM_1 --Msg缓冲区1
   1005           *      |___ MSG_NUM_2 --Msg缓冲区2
   1006           *      |___ MSG_NUM_3 --Msg缓冲区3
   1007           *      |___ MSG_NUM_4 --Msg缓冲区4
   1008           *      ...... 
   1009           *      |___ MSG_NUM_15 --Msg缓冲区15
   1010           * 输出:
   1011           *    无 
   1012           */

   \                                 In section .text, align 2, keep-with-next
   1013          static void LPLD_CAN_Receive_Interrupt(CAN_Type *canx, uint8 msg_num)
   1014          {
   \                     LPLD_CAN_Receive_Interrupt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1015            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num) == 1)
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x....'....        BL       LPLD_CAN_Interrupt_GetFlag
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD125             BNE.N    ??LPLD_CAN_Receive_Interrupt_0
   1016            {
   1017              //如果定义了中断回掉函数，在此执行
   1018              if(canx == CAN0)
   \       0x14   0x....             LDR.N    R0,??DataTable19_5  ;; 0x40024000
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD10C             BNE.N    ??LPLD_CAN_Receive_Interrupt_1
   1019              {
   1020                if( CAN0_ISR[msg_num] != NULL)
   \       0x1A   0x....             LDR.N    R1,??DataTable19_28
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD016             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   1021                {
   1022                    CAN0_ISR[msg_num]();
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x30   0x4780             BLX      R0
   \       0x32   0xE010             B.N      ??LPLD_CAN_Receive_Interrupt_2
   1023                }
   1024              }
   1025              else if (canx == CAN1)
   \                     ??LPLD_CAN_Receive_Interrupt_1: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable19_26  ;; 0x400a4000
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xD10C             BNE.N    ??LPLD_CAN_Receive_Interrupt_3
   1026              {
   1027                if( CAN1_ISR[msg_num] != NULL)
   \       0x3A   0x....             LDR.N    R1,??DataTable19_29
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x40   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD006             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   1028                {
   1029                    CAN1_ISR[msg_num]();
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x50   0x4780             BLX      R0
   \       0x52   0xE000             B.N      ??LPLD_CAN_Receive_Interrupt_2
   1030                }
   1031              }
   1032              else
   1033              {
   1034                return;
   \                     ??LPLD_CAN_Receive_Interrupt_3: (+1)
   \       0x54   0xE004             B.N      ??LPLD_CAN_Receive_Interrupt_4
   1035              }
   1036              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_Receive_Interrupt_2: (+1)
   \       0x56   0x0029             MOVS     R1,R5
   \       0x58   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x....'....        BL       LPLD_CAN_Interrupt_ClearPending
   1037            }
   1038          }
   \                     ??LPLD_CAN_Receive_Interrupt_0: (+1)
   \                     ??LPLD_CAN_Receive_Interrupt_4: (+1)
   \       0x60   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1039          /*
   1040           * LPLD_CAN_MB_ISR
   1041           * CANx中断处理函数
   1042           * 
   1043           * 参数:
   1044           *    无
   1045           * 输出:
   1046           *    无 
   1047           */

   \                                 In section .text, align 2, keep-with-next
   1048          static void LPLD_CAN_MB_ISR(void)
   1049          {
   \                     LPLD_CAN_MB_ISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1050            uint8 msg_obj;
   1051            
   1052            for (msg_obj = 0; msg_obj < MSG_MAX_NO; msg_obj++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??LPLD_CAN_MB_ISR_0: (+1)
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x2810             CMP      R0,#+16
   \        0xA   0xDA27             BGE.N    ??LPLD_CAN_MB_ISR_1
   1053            {
   1054              if(flexcan_msgobj_param_t[msg_obj].CAN_Canx != NULL)
   \        0xC   0x....             LDR.N    R2,??DataTable19_30
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x12   0x0100             LSLS     R0,R0,#+4
   \       0x14   0x5810             LDR      R0,[R2, R0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD01E             BEQ.N    ??LPLD_CAN_MB_ISR_2
   1055              {
   1056                if(flexcan_msgobj_param_t[msg_obj].CAN_MsgDirection == CAN_MSGOBJ_DIR_TX)
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1E   0x0100             LSLS     R0,R0,#+4
   \       0x20   0x4410             ADD      R0,R2,R0
   \       0x22   0x7A00             LDRB     R0,[R0, #+8]
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD108             BNE.N    ??LPLD_CAN_MB_ISR_3
   1057                {
   1058                  LPLD_CAN_Transmit_Interrupt(flexcan_msgobj_param_t[msg_obj].CAN_Canx,msg_obj);
   \       0x28   0x0021             MOVS     R1,R4
   \       0x2A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x30   0x0100             LSLS     R0,R0,#+4
   \       0x32   0x5810             LDR      R0,[R2, R0]
   \       0x34   0x....'....        BL       LPLD_CAN_Transmit_Interrupt
   \       0x38   0xE00E             B.N      ??LPLD_CAN_MB_ISR_2
   1059                }
   1060                else if(flexcan_msgobj_param_t[msg_obj].CAN_MsgDirection == CAN_MSGOBJ_DIR_RX)
   \                     ??LPLD_CAN_MB_ISR_3: (+1)
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3E   0x0100             LSLS     R0,R0,#+4
   \       0x40   0x4410             ADD      R0,R2,R0
   \       0x42   0x7A00             LDRB     R0,[R0, #+8]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD107             BNE.N    ??LPLD_CAN_MB_ISR_2
   1061                {
   1062                  LPLD_CAN_Receive_Interrupt(flexcan_msgobj_param_t[msg_obj].CAN_Canx,msg_obj);
   \       0x48   0x0021             MOVS     R1,R4
   \       0x4A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x50   0x0100             LSLS     R0,R0,#+4
   \       0x52   0x5810             LDR      R0,[R2, R0]
   \       0x54   0x....'....        BL       LPLD_CAN_Receive_Interrupt
   1063                }
   1064                else
   1065                {}
   1066              }
   1067            }
   \                     ??LPLD_CAN_MB_ISR_2: (+1)
   \       0x58   0x1C64             ADDS     R4,R4,#+1
   \       0x5A   0xE7D3             B.N      ??LPLD_CAN_MB_ISR_0
   1068          }
   \                     ??LPLD_CAN_MB_ISR_1: (+1)
   \       0x5C   0xBD10             POP      {R4,PC}          ;; return
   1069          /*
   1070           * CAN0中断处理函数
   1071           * 与启动文件startup_K60.s中的中断向量表关联
   1072           * 用户无需修改，程序自动进入对应通道中断函数
   1073           */

   \                                 In section .text, align 2, keep-with-next
   1074          void CAN0_MESS_IRQHandler(void)
   1075          {
   \                     CAN0_MESS_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1076          #if (UCOS_II > 0u)
   1077            OS_CPU_SR  cpu_sr = 0u;
   1078            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1079            OSIntEnter();
   1080            OS_EXIT_CRITICAL();
   1081          #endif
   1082            LPLD_CAN_MB_ISR();
   \        0x2   0x....'....        BL       LPLD_CAN_MB_ISR
   1083          #if (UCOS_II > 0u)
   1084            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1085          #endif
   1086          }      
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
   1087          //29:  CAM 0 OR'ed Message buffer (0-15)
   1088          

   \                                 In section .text, align 2, keep-with-next
   1089          void CAN0_BUS_OFF_IRQHandler(void)
   1090          {
   1091            CAN0->ESR1 = CAN_ESR1_BOFFINT_MASK;
   \                     CAN0_BUS_OFF_IRQHandler: (+1)
   \        0x0   0x2004             MOVS     R0,#+4
   \        0x2   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \        0x4   0x6008             STR      R0,[R1, #+0]
   1092          }   //38:  CAM 0 Bus Off
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1093          void CAN0_ERR_IRQHandler(void)
   1094          {
   1095            uint32_t status;
   1096          
   1097            status = CAN0->ESR1;
   \                     CAN0_ERR_IRQHandler: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   1098          
   1099            if( status  & CAN_ESR1_ERRINT_MASK)
   \        0x4   0x0782             LSLS     R2,R0,#+30
   \        0x6   0xD500             BPL.N    ??CAN0_ERR_IRQHandler_0
   1100            {
   1101              CAN0->ESR1 = status;		
   \        0x8   0x6008             STR      R0,[R1, #+0]
   1102            }	
   1103          }       //39:  CAM 0 Error
   \                     ??CAN0_ERR_IRQHandler_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1104          void CAN0_TW_IRQHandler(void)
   1105          {
   1106            CAN0->ESR1 = CAN_ESR1_TWRNINT_MASK;
   \                     CAN0_TW_IRQHandler: (+1)
   \        0x0   0xF45F 0x3000      MOVS     R0,#+131072
   \        0x4   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \        0x6   0x6008             STR      R0,[R1, #+0]
   1107          }        //40:  CAM 0 Transmit Warning
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1108          void CAN0_RW_IRQHandler(void)
   1109          {
   1110            CAN0->ESR1 = CAN_ESR1_RWRNINT_MASK;
   \                     CAN0_RW_IRQHandler: (+1)
   \        0x0   0xF45F 0x3080      MOVS     R0,#+65536
   \        0x4   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \        0x6   0x6008             STR      R0,[R1, #+0]
   1111          }        //41:  CAM 0 Receive Warning
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1112          void CAN0_WAKE_UP_IRQHandler(void){}   //42:  CAM 0 WakeUp
   \                     CAN0_WAKE_UP_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1113          void CAN0_IMEU_IRQHandler(void){}      //43:  CAM 0 Individual Matching Elements Update (IMEU)
   \                     CAN0_IMEU_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1114          void CAN0_LR_IRQHandler(void){}        //44:  CAM 0 Lost receive
   \                     CAN0_LR_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1115          
   1116          /*
   1117           * CAN1中断处理函数
   1118           * 与启动文件startup_K60.s中的中断向量表关联
   1119           * 用户无需修改，程序自动进入对应通道中断函数
   1120           */

   \                                 In section .text, align 2, keep-with-next
   1121          void CAN1_MESS_IRQHandler(void)
   1122          {
   \                     CAN1_MESS_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1123          #if (UCOS_II > 0u)
   1124            OS_CPU_SR  cpu_sr = 0u;
   1125            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1126            OSIntEnter();
   1127            OS_EXIT_CRITICAL();
   1128          #endif
   1129            LPLD_CAN_MB_ISR();
   \        0x2   0x....'....        BL       LPLD_CAN_MB_ISR
   1130          #if (UCOS_II > 0u)
   1131            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1132          #endif
   1133          }
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
   1134          //37:  CAM 1 OR'ed Message buffer (0-15)
   1135          

   \                                 In section .text, align 2, keep-with-next
   1136          void CAN1_BUS_OFF_IRQHandler(void)
   1137          {
   1138            CAN1->ESR1 = CAN_ESR1_BOFFINT_MASK;
   \                     CAN1_BUS_OFF_IRQHandler: (+1)
   \        0x0   0x2004             MOVS     R0,#+4
   \        0x2   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \        0x4   0x6008             STR      R0,[R1, #+0]
   1139          }   //38:  CAM 1 Bus Off
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1140          void CAN1_ERR_IRQHandler(void)
   1141          {
   1142            uint32_t status;
   1143          
   1144            status = CAN1->ESR1;
   \                     CAN1_ERR_IRQHandler: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   1145          
   1146            if( status  & CAN_ESR1_ERRINT_MASK)
   \        0x4   0x0782             LSLS     R2,R0,#+30
   \        0x6   0xD500             BPL.N    ??CAN1_ERR_IRQHandler_0
   1147            {
   1148              CAN1->ESR1 = status;		
   \        0x8   0x6008             STR      R0,[R1, #+0]
   1149            }	
   1150          }       //39:  CAM 1 Error
   \                     ??CAN1_ERR_IRQHandler_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1151          void CAN1_TW_IRQHandler(void)
   1152          {
   1153            CAN1->ESR1 = CAN_ESR1_TWRNINT_MASK;
   \                     CAN1_TW_IRQHandler: (+1)
   \        0x0   0xF45F 0x3000      MOVS     R0,#+131072
   \        0x4   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \        0x6   0x6008             STR      R0,[R1, #+0]
   1154          }        //40:  CAM 1 Transmit Warning
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1155          void CAN1_RW_IRQHandler(void)
   1156          {
   1157            CAN1->ESR1 = CAN_ESR1_RWRNINT_MASK;
   \                     CAN1_RW_IRQHandler: (+1)
   \        0x0   0xF45F 0x3080      MOVS     R0,#+65536
   \        0x4   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \        0x6   0x6008             STR      R0,[R1, #+0]
   1158          }        //41:  CAM 1 Receive Warning
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1159          void CAN1_WAKE_UP_IRQHandler(void){}   //42:  CAM 1 WakeUp
   \                     CAN1_WAKE_UP_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1160          void CAN1_IMEU_IRQHandler(void){}      //43:  CAM 1 Individual Matching Elements Update (IMEU)
   \                     CAN1_IMEU_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1161          void CAN1_LR_IRQHandler(void){}        //44:  CAM 1 Lost receive
   \                     CAN1_LR_IRQHandler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x000F'4241        DC32     0xf4241

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x4006'5000        DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \        0x0   0x4002'4000        DC32     0x40024000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \        0x0   0x4004'803C        DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \        0x0   0x4004'8030        DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \        0x0   0x4004'A048        DC32     0x4004a048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \        0x0   0x4004'9030        DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \        0x0   0x4004'A04C        DC32     0x4004a04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \        0x0   0x4004'9034        DC32     0x40049034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \        0x0   0x4004'B044        DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \        0x0   0x4004'D060        DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \        0x0   0x4004'B040        DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_15:
   \        0x0   0x4004'D064        DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_16:
   \        0x0   0x0001'4585        DC32     0x14585

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_17:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_18:
   \        0x0   0x0001'E848        DC32     0x1e848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_19:
   \        0x0   0x0003'D090        DC32     0x3d090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_20:
   \        0x0   0x0007'A120        DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_21:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_22:
   \        0x0   0x....'....        DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_23:
   \        0x0   0x0001'0003        DC32     0x10003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_24:
   \        0x0   0x009B'0002        DC32     0x9b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_25:
   \        0x0   0x005B'0002        DC32     0x5b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_26:
   \        0x0   0x400A'4000        DC32     0x400a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_27:
   \        0x0   0x1FFC'0000        DC32     0x1ffc0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_28:
   \        0x0   0x....'....        DC32     CAN0_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_29:
   \        0x0   0x....'....        DC32     CAN1_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_30:
   \        0x0   0x....'....        DC32     flexcan_msgobj_param_t

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_31:
   \        0x0   0x4002'4020        DC32     0x40024020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_32:
   \        0x0   0x400A'4020        DC32     0x400a4020

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x47 0x3A          DC8 "G:\\AIcar\\\344\277\241\346\240\207\\xiugai\\lib\\LPLD\\HW\\HW_CAN.c"
   \              0x5C 0x41    
   \              0x49 0x63    
   \              0x61 0x72    
   \              0x5C 0xE4    
   \              0xBF 0xA1    
   \              0xE6 0xA0    
   \              0x87 0x5C    
   \              0x78 0x69    
   \              0x75 0x67    
   \              0x61 0x69    
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \              0x50 0x4C    
   \              0x44 0x5C    
   \              0x48 0x57    
   \              0x5C 0x48    
   \              0x57 0x5F    
   \              0x43 0x41    
   \              0x4E 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000  
   1162          
   1163          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN0_BUS_OFF_IRQHandler
       0   CAN0_ERR_IRQHandler
       0   CAN0_IMEU_IRQHandler
       0   CAN0_LR_IRQHandler
       8   CAN0_MESS_IRQHandler
         8   -> LPLD_CAN_MB_ISR
       0   CAN0_RW_IRQHandler
       0   CAN0_TW_IRQHandler
       0   CAN0_WAKE_UP_IRQHandler
       0   CAN1_BUS_OFF_IRQHandler
       0   CAN1_ERR_IRQHandler
       0   CAN1_IMEU_IRQHandler
       0   CAN1_LR_IRQHandler
       8   CAN1_MESS_IRQHandler
         8   -> LPLD_CAN_MB_ISR
       0   CAN1_RW_IRQHandler
       0   CAN1_TW_IRQHandler
       0   CAN1_WAKE_UP_IRQHandler
      24   LPLD_CAN_Deinit
        24   -> __NVIC_DisableIRQ
        24   -> __NVIC_EnableIRQ
      24   LPLD_CAN_DisableIrq
        24   -> __NVIC_DisableIRQ
      24   LPLD_CAN_EnableIrq
        24   -> __NVIC_EnableIRQ
       4   LPLD_CAN_EnableMsgInterrupt
      24   LPLD_CAN_GetData
       0   LPLD_CAN_GetMsgCode
       0   LPLD_CAN_GetMsgID
       0   LPLD_CAN_GetMsgLength
       0   LPLD_CAN_GetMsgTimeStamp
      40   LPLD_CAN_Init
        40   -> LPLD_CAN_SetBaudRate
        40   -> assert_failed
      56   LPLD_CAN_InitMessageObject
        56   -> LPLD_CAN_EnableMsgInterrupt
       4   LPLD_CAN_Interrupt_ClearPending
       0   LPLD_CAN_Interrupt_GetFlag
       8   LPLD_CAN_MB_ISR
         8   -> LPLD_CAN_Receive_Interrupt
         8   -> LPLD_CAN_Transmit_Interrupt
      16   LPLD_CAN_Receive_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
      64   LPLD_CAN_ReceivedMessage
        64   -> LPLD_CAN_GetData
        64   -> LPLD_CAN_GetMsgCode
        64   -> LPLD_CAN_GetMsgID
        64   -> LPLD_CAN_GetMsgLength
        64   -> LPLD_CAN_GetMsgTimeStamp
        64   -> LPLD_CAN_Interrupt_ClearPending
        64   -> LPLD_CAN_SetMsgCode
        64   -> LPLD_CAN_UnlockMsg
        64   -> memcpy
      16   LPLD_CAN_SetBaudRate
        16   -> assert_failed
       4   LPLD_CAN_SetMsgCode
      64   LPLD_CAN_TransmitMessage
        64   -> LPLD_CAN_GetMsgCode
        64   -> LPLD_CAN_WriteData
      16   LPLD_CAN_Transmit_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
       0   LPLD_CAN_UnlockMsg
      32   LPLD_CAN_WriteData
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_32
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      44  ?_0
       8  ?_1
       8  CAN0_BUS_OFF_IRQHandler
      12  CAN0_ERR_IRQHandler
       2  CAN0_IMEU_IRQHandler
      64  CAN0_ISR
       2  CAN0_LR_IRQHandler
       8  CAN0_MESS_IRQHandler
      10  CAN0_RW_IRQHandler
      10  CAN0_TW_IRQHandler
       2  CAN0_WAKE_UP_IRQHandler
       8  CAN1_BUS_OFF_IRQHandler
      12  CAN1_ERR_IRQHandler
       2  CAN1_IMEU_IRQHandler
      64  CAN1_ISR
       2  CAN1_LR_IRQHandler
       8  CAN1_MESS_IRQHandler
      10  CAN1_RW_IRQHandler
      10  CAN1_TW_IRQHandler
       2  CAN1_WAKE_UP_IRQHandler
      78  LPLD_CAN_Deinit
      38  LPLD_CAN_DisableIrq
      38  LPLD_CAN_EnableIrq
      40  LPLD_CAN_EnableMsgInterrupt
     148  LPLD_CAN_GetData
      16  LPLD_CAN_GetMsgCode
      58  LPLD_CAN_GetMsgID
      18  LPLD_CAN_GetMsgLength
      14  LPLD_CAN_GetMsgTimeStamp
     520  LPLD_CAN_Init
     220  LPLD_CAN_InitMessageObject
      40  LPLD_CAN_Interrupt_ClearPending
      36  LPLD_CAN_Interrupt_GetFlag
      94  LPLD_CAN_MB_ISR
      98  LPLD_CAN_Receive_Interrupt
     196  LPLD_CAN_ReceivedMessage
     196  LPLD_CAN_SetBaudRate
      42  LPLD_CAN_SetMsgCode
     244  LPLD_CAN_TransmitMessage
      94  LPLD_CAN_Transmit_Interrupt
       6  LPLD_CAN_UnlockMsg
     286  LPLD_CAN_WriteData
      40  __NVIC_DisableIRQ
      32  __NVIC_EnableIRQ
     256  flexcan_msgobj_param_t

 
   384 bytes in section .bss
    52 bytes in section .rodata
 2 832 bytes in section .text
 
 2 832 bytes of CODE  memory
    52 bytes of CONST memory
   384 bytes of DATA  memory

Errors: none
Warnings: 1
